{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"source/assets/image/favicon.ico","path":"assets/image/favicon.ico","modified":0,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"source/assets/image/avator.jpeg","path":"assets/image/avator.jpeg","modified":0,"renderable":0},{"_id":"source/assets/blog/totoro.jpeg","path":"assets/blog/totoro.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1554618464000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1554618464000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1554618464000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1554618464000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1554618464000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1554618464000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1554618464000},{"_id":"themes/yilia/_config.yml","hash":"886f646dfc0b7d16e99a0979e4d4f7ac865fbdfb","modified":1554697856000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1554618464000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1554618464000},{"_id":"source/_posts/demo.md","hash":"cc508572e2e07cb68e4e7e75e07c5d6e5130b3c1","modified":1554730898046},{"_id":"source/_posts/test.md","hash":"4ea22ae3752e842bc490f342a9208e12d7662d12","modified":1554734285083},{"_id":"source/_posts/today-is-sunday.md","hash":"bf5d51edbc8553ebf74c812e84c32668172ed0a1","modified":1554894459980},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1554618464000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1554618464000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1554618464000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1554618464000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1554618464000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1554618464000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1554618464000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1554618464000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1554618464000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1554618464000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1554618464000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1554618464000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1554618464000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1554618464000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1554618464000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1554618464000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1554618464000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1554618464000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"5299bd43c93dabe6eacb96ae9f83271c49c5909d","modified":1554698378000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1554618464000},{"_id":"source/assets/image/favicon.ico","hash":"c7dcd652fa9ed927d0ec2e0580f5de1ae9ddbdff","modified":1554730898049},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1554618464000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1554618464000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1554618464000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1554618464000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1554618464000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1554618464000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1554618464000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1554618464000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1554618464000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1554618464000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1554618464000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1554618464000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1554618464000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1554618464000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1554618464000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1554618464000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1554618464000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1554618464000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1554618464000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1554618464000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1554618464000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1554618464000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1554618464000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1554618464000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1554618464000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1554618464000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1554618464000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1554618464000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1554618464000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1554618464000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1554618464000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1554618464000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1554618464000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1554618464000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1554618464000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1554618464000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1554618464000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1554618464000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1554618464000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1554618464000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1554618464000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1554618464000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1554618464000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1554618464000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1554618464000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1554618464000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1554618464000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1554618464000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1554618464000},{"_id":"source/_posts/test/head.jpeg","hash":"614f22cdbeb97afe962d213915c1cf65e3a2c237","modified":1554730898047},{"_id":"source/assets/image/avator.jpeg","hash":"614f22cdbeb97afe962d213915c1cf65e3a2c237","modified":1554730898049},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1554618464000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1554618464000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1554618464000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1554618464000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1554618464000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1554618464000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1554618464000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1554618464000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1554618464000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1554618464000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1554618464000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1554618464000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1554618464000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1554618464000},{"_id":"source/assets/blog/totoro.jpeg","hash":"30bc504edb2e9bd4ef8a4e2321f0d0f4c8283a91","modified":1554730898048},{"_id":"public/content.json","hash":"1266ecd43a76fdc4ab8da0738478535397c9a9c1","modified":1554812145806},{"_id":"public/atom.xml","hash":"5ecc3de837e139dabed9210828538869c05918da","modified":1554812777606},{"_id":"public/2019/04/09/today-is-sunday/index.html","hash":"a99200418be350aa4af5be2df64bc30c8f5bc451","modified":1554812777907},{"_id":"public/2019/04/07/test/index.html","hash":"4ac06e6bf12b19a2f24133763bcebf24635cc127","modified":1554812146083},{"_id":"public/2015/10/21/demo/index.html","hash":"a4d19a6b5ba50a67f07b38ebb7267d74c31dbb7a","modified":1554812146083},{"_id":"public/archives/index.html","hash":"23b88bc94b9a94d5673b2b0c75c8825dbcb9d90b","modified":1554812146083},{"_id":"public/archives/2015/index.html","hash":"46eb768f667fb106ca8109c1e333ea8f8c7d1333","modified":1554812146084},{"_id":"public/archives/2015/10/index.html","hash":"94face239ea631b25ddb78f028675a870879ab74","modified":1554812146084},{"_id":"public/archives/2019/index.html","hash":"22f56dd38b4f2d952a82f17a4460771ab407f3c2","modified":1554812146084},{"_id":"public/archives/2019/04/index.html","hash":"cc22cc0b755748352248dbc6f269b6ef776dc64b","modified":1554812146084},{"_id":"public/index.html","hash":"7e35129abe039c47e9c411d898f012c52f459891","modified":1554812777908},{"_id":"public/tags/标签1/index.html","hash":"17b9b555449f8d2ba1a1c4cd4a050ed481e0f34d","modified":1554812146084},{"_id":"public/tags/日记/index.html","hash":"2d367b77098a13ea03b908c0c12090d97a23b95c","modified":1554812146084},{"_id":"public/tags/测试标签/index.html","hash":"377efea18bee1fe869b37eb1af4172fbd01fad04","modified":1554812146085},{"_id":"public/tags/css/index.html","hash":"1c2605967bf2a2aa5866bcc1bc286773948ca295","modified":1554812146085},{"_id":"public/tags/学习Vlog/index.html","hash":"f94e64697ebff27afa5b4a1bc8734990b6722777","modified":1554812146085},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1554812146089},{"_id":"public/assets/image/favicon.ico","hash":"c7dcd652fa9ed927d0ec2e0580f5de1ae9ddbdff","modified":1554812146089},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1554812146090},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1554812146090},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1554812146090},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1554812146090},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1554812146090},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1554812146090},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1554812146090},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1554812146090},{"_id":"public/assets/image/avator.jpeg","hash":"614f22cdbeb97afe962d213915c1cf65e3a2c237","modified":1554812146091},{"_id":"public/assets/blog/totoro.jpeg","hash":"30bc504edb2e9bd4ef8a4e2321f0d0f4c8283a91","modified":1554812146095},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1554812146099},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1554812146099},{"_id":"public/main.0cf68a.js","hash":"5299bd43c93dabe6eacb96ae9f83271c49c5909d","modified":1554812146100},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1554812146102}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"test","date":"2019-04-07T06:51:29.000Z","_content":"\n一些在目录菜单显示的，文章简介内容。\n\n<!-- more -->\n\n#### 标题\n<p><image src=\"http://bayuefen.oss-cn-hangzhou.aliyuncs.com/test/totoro.jpeg?x-oss-process=style/compress_high\" width=\"400\" align=\"center\"></p>\n\n","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2019-04-07 14:51:29\ntags: \n   - 标签1\n   - 测试标签\n---\n\n一些在目录菜单显示的，文章简介内容。\n\n<!-- more -->\n\n#### 标题\n<p><image src=\"http://bayuefen.oss-cn-hangzhou.aliyuncs.com/test/totoro.jpeg?x-oss-process=style/compress_high\" width=\"400\" align=\"center\"></p>\n\n","slug":"test","published":1,"updated":"2019-04-08T14:38:05.083Z","_id":"cju8garob0000qovlrvz3byax","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一些在目录菜单显示的，文章简介内容。</p>\n<a id=\"more\"></a>\n<h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><p><image src=\"http://bayuefen.oss-cn-hangzhou.aliyuncs.com/test/totoro.jpeg?x-oss-process=style/compress_high\" width=\"400\" align=\"center\"></image></p>\n\n","site":{"data":{}},"excerpt":"<p>一些在目录菜单显示的，文章简介内容。</p>","more":"<h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><p><image src=\"http://bayuefen.oss-cn-hangzhou.aliyuncs.com/test/totoro.jpeg?x-oss-process=style/compress_high\" width=\"400\" align=\"center\"></image></p>"},{"title":"HTTP协议学习","date":"2019-04-09T14:08:32.000Z","_content":"一些学习笔记。\n<!-- more -->\n\n### HTTP协议\nHTTP协议是客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”全称为“Hyper Text Transfer Protocol”。\n### HTTP/2协议\n1、二进制分帧层 (Binary Framing Layer)\n2、在单个TCP连接里多路复用请求。\n3、HTTP/2的Server Push，非常重要的一个特性。\n4、HTTP Header的压缩，采用的是HPack算法。\n5、应用层的重置连接\n6、请求优先级设置\n7、流量控制\n8、HTTP/1 的几种优化可以弃用\n参考：https://blog.wangriyu.wang/2018/05-HTTP2.html\n\n### HTTP协议在OSI模型的位置\nHTTP协议位于应用层\n![OSI &TCP协议模型对比 ](https://img-blog.csdnimg.cn/20190406164742398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JheXVlZmVuODg2,size_16,color_FFFFFF,t_70)\n\n### HTTP协议的method\nGET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.\n\n```\n>>> r = requests.get('https://api.github.com/events')\n```\n\nHEAD：请求一个与GET请求的响应相同的响应，但没有响应体.\n\n```\n>>> r = requests.head('http://httpbin.org/get')\n```\n\nPOST：用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改. \n```\n>>> r = requests.post('http://httpbin.org/post', data = {'key':'value'})\n```\n\nPUT：用请求有效载荷替换目标资源的所有当前表示。\n\n```\n>>> r = requests.put('http://httpbin.org/put', data = {'key':'value'})\n```\n\nDELETE：删除指定的资源。\n\n```\n>>> r = requests.delete('http://httpbin.org/delete')\n```\n\nCONNECT：建立一个到由目标资源标识的服务器的隧道。\n\nOPTIONS：用于描述目标资源的通信选项。\n\n```\n>>> r = requests.options('http://httpbin.org/get')\n```\n\nTRACE：沿着到目标资源的路径执行一个消息环回测试。\n\nPATCH：用于对资源应用部分修改。\n\nGET和POST对比：\nGET\n1.方法用途\nGET 方法的首要目的是 获取资源\n\n2.方法特点\na) 参数可见\nGET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法\n不过也正是因此，所以 GET 方法允许被保存书签\n\nb) 数据类型只允许 ASCII\nGET 方法的数据类型只允许是 ASCII 字符，所以说传递 二进制 文件就不可以用 GET 方法了哦\n\nc) 可以保存书签\n当我们访问某一个网站的频率特别高的时候，肯定添加到书签，那其实书签就是依靠 GET 方法来保存的\n\nd) 可以被缓存\nGET 方法支持缓存，当本次请求允许被缓存时，会将资源存值本地 cache ，在未过期的情况下直接取本地 cache；缓存过期后视情况而定\n\ne) 参数会保留在浏览器历史记录\n比较直观的感受就是，我们可以在浏览器的历史记录中查看到曾经搜索过的关键字信息\n\nf) 请求长度会受限于所使用的浏览器与服务器\n不同的浏览器对于 GET 请求长度的限制也是不同的，注意这是 浏览器 / 服务器（IE、Chrome、Apache、IIS等） 对于长度的限制，而不是 HTTP 协议\n\nPOST\n1.方法用途\nPOST 方法的首要目的是 提交，POST 方法一般用于添加资源\n\n2.方法特点\na) 参数不可见，也不会被保存\n所以说 POST 方法是不可以被保存书签的\n\nb) 不能收藏为书签\n理由如上\n\nc) 不可以被缓存\n我要提交的数据被缓存在本地 cache 中想想其实也是没道理的\n\nd) 不会被保存在浏览器历史中\n同样是因为参数不可见\n\ne) 不限制请求长度\n对于 POST 方法这种以 提交 为首要目的的方法，肯定是不可以限制请求长度的\n\nf) 数据类型\n不限，所以说 POST 是可以 提交文件 到服务器的\n\ng) 请求方式\nPOST 请求与 GET 请求不同，他会首先提交 HEAD 信息，待得到 100 响应后，才会再次将 DATA 提交\n\n### HTTP协议的组成\n请求报文包含三部分：\n**·**请求行(Request line)：包含请求方法、URI、HTTP版本信息\n**·**请求首部字段(Request header)\n**·**请求内容实体\n响应报文包含三部分：（以豆瓣电影TOP250为例）\n>Request Headers\n\n> GET /top250 HTTP/1.1              \n\\#GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。\nHost: movie.douban.com\n\\#表示请求的域名是movie.douban.com\nConnection: keep-alive\n\\#表示支持长连接\nCache-Control: max-age=0\n\\#指定请求和响应遵循的缓存机制\nUpgrade-Insecure-Requests: 1\n\\#浏览器可以处理https协议\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\n\\#发出请求的用户信息\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\n\\#客户端希望接受的数据类型\nAccept-Encoding: gzip, deflate, br\n\\#浏览器发给服务器,声明浏览器支持的编码类型\nAccept-Language: zh-CN,zh;q=0.9\n\\#浏览器支持的语言分别是简体中文和中文，优先支持简体中文。\nCookie: bid=ZbyUzrJdS2w; __utmc=30149280; __utmc=223695111; __yadk_uid=nTiBvU6fTOaXD90dB6edYhp8urhJwCjc; viewed=\"27599884\"; gr_user_id=4aa3ad30-748f-488c-b5b3-bcff3f0456d4; douban-fav-remind=1; ll=\"118172\"; _vwo_uuid_v2=DE51C937E99B505F3A54AE46B8619B83A|80d039133d473653fabc07636080bbb8; push_noty_num=0; push_doumail_num=0; __utmv=30149280.19454; ap_v=0,6.0; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1554617137%2C%22https%3A%2F%2Fwww.\nbaidu.com%2Flink%3Furl%3Dt8BO_5f8zl_78xcE_dnmyhd_1xbKVsXtXZv_yHxp72UVO88nbOSLQSA1xMPpsfX2%26wd%3\nD%26eqid%3Da8c4f714000c0677000000035ca9932e%22%5D;\n _pk_id.100001.4cf6=e94317b751ae8229.1554384156.13.1554617137.1554583408.; _pk_ses.100001.4cf6=*; __utma=30149280.106710662.1554384144.1554583409.1554617137.12; __utmb=30149280.0.10.1554617137; __utmz=30149280.1554617137.12.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; __utma=223695111.1166551075.1554384156.1554583409.1554617137.13; __utmb=223695111.0.10.1554617137; __utmz=223695111.1554617137.13.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic\n\\#http是无状态的，所以引入了cookie来管理服务器与客户端之间的状态\n\n响应报文包含三部分：\n**·**状态行：包含HTTP版本、状态码、状态码的原因短语\n**·**响应首部字段\n**·**响应内容实体\n> Response header\n\n> HTTP/1.1 200 OK\n\\#响应状态\nDate: Sun, 07 Apr 2019 06:05:45 GMT\n\\#生成消息的具体时间和日期\nContent-Type: text/html; charset=utf-8\n\\#服务器发送 html 文档，字符集为 UTF-8\nTransfer-Encoding: chunked\nConnection: keep-alive\nKeep-Alive: timeout=30\nVary: Accept-Encoding\n\\#服务器响应时根据请求头中的的值返回不同的内容\nX-Xss-Protection: 1; mode=block\n设置浏览器的XSS防护机制，浏览器如果检测到恶意代码，则不渲染恶意代码\nX-Douban-Mobileapp: 0\nExpires: Sun, 1 Jan 2006 01:00:00 GMT\n浏览器会在指定过期时间内使用本地缓存\nPragma: no-cache\nCache-Control: must-revalidate, no-cache, private\nX-DAE-Node: brand4\nX-DAE-App: movie\nServer: dae\nX-Content-Type-Options: nosniff\nContent-Encoding: gzip\n文档使用的 MIME 类型是 text/html，并且对内容进行了 gzip 压缩\n\n### HTTP协议的状态码\n1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。\n2xx （成功） 表示成功处理了请求的状态代码。\n3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\n4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。\n5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。\n常见的：200 – 服务器成功返回网页 |404 – 请求的网页不存在 |503 – 服务不可用 \n\n状态码                     |中文描述 \n:--------------------:|:--------------------:\n100|（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  \n101|（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。\n102|（已接受）已经接受请求，但未处理完成\n200| （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n201|（已创建）  请求成功并且服务器创建了新的资源。\n202|（已接受）  服务器已接受请求，但尚未处理。\n203|（非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204|（无内容）  服务器成功处理了请求，但没有返回任何内容。\n205|（重置内容） 服务器成功处理了请求，但没有返回任何内容。 \n206|（部分内容）  服务器成功处理了部分 GET 请求。\n300|（多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 \n301|（永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n302|（临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n303|（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。\n304|（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 \n305|（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。\n307|（临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n400|（错误请求） 服务器不理解请求的语法。\n401|未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 \n403|（禁止） 服务器拒绝请求。 \n404|（未找到） 服务器找不到请求的网页。 \n405|（方法禁用） 禁用请求中指定的方法。\n406|（不接受） 无法使用请求的内容特性响应请求的网页。 \n407|（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。\n408|（请求超时）  服务器等候请求时发生超时。 \n409|（冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 \n410|（已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 \n411|（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 \n412|（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 \n413|（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 \n414|（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 \n415|（不支持的媒体类型） 请求的格式不受请求页面的支持。 \n416|（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 \n417|（未满足期望值） 服务器未满足”期望”请求标头字段的要求。\n500|（服务器内部错误）  服务器遇到错误，无法完成请求。 \n501|（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。\n502|（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\n503|（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 \n504|（网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 \n505|（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\n  \n  \n<p><image src=\"https://bayuefen.oss-cn-hangzhou.aliyuncs.com/test/44c8b6f9835b1f07ac9bf0e8cb399b16.jpg.source.jpg?x-oss-process=style/compress_high\n\" width=\"400\" align=\"center\"></p>\n\n### cookies和会话\n因为HTTP是无状态的，对事物处理没有记忆能力。cookies和会话出现用于保持HTTP连接状态，\n会话在服务端，用来保存用户的会话信息；cookies在客户端，浏览器下次访问网页时会自动附带上它发送给服务器，\n服务器通过识别cookies找到对应的会话判断用户状态。\nPS:关闭浏览器不会导致会话被删除，反而没有存储到硬盘上的cookie会消失，因此为了节省存储空间需要为会话设置一个失效时间。\n\n假如说我写完了哦。。。\n","source":"_posts/today-is-sunday.md","raw":"---\ntitle: HTTP协议学习\ndate: 2019-04-09 22:08:32\ntags:\n    - 日记\n    - 学习Vlog\n---\n一些学习笔记。\n<!-- more -->\n\n### HTTP协议\nHTTP协议是客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”全称为“Hyper Text Transfer Protocol”。\n### HTTP/2协议\n1、二进制分帧层 (Binary Framing Layer)\n2、在单个TCP连接里多路复用请求。\n3、HTTP/2的Server Push，非常重要的一个特性。\n4、HTTP Header的压缩，采用的是HPack算法。\n5、应用层的重置连接\n6、请求优先级设置\n7、流量控制\n8、HTTP/1 的几种优化可以弃用\n参考：https://blog.wangriyu.wang/2018/05-HTTP2.html\n\n### HTTP协议在OSI模型的位置\nHTTP协议位于应用层\n![OSI &TCP协议模型对比 ](https://img-blog.csdnimg.cn/20190406164742398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JheXVlZmVuODg2,size_16,color_FFFFFF,t_70)\n\n### HTTP协议的method\nGET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.\n\n```\n>>> r = requests.get('https://api.github.com/events')\n```\n\nHEAD：请求一个与GET请求的响应相同的响应，但没有响应体.\n\n```\n>>> r = requests.head('http://httpbin.org/get')\n```\n\nPOST：用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改. \n```\n>>> r = requests.post('http://httpbin.org/post', data = {'key':'value'})\n```\n\nPUT：用请求有效载荷替换目标资源的所有当前表示。\n\n```\n>>> r = requests.put('http://httpbin.org/put', data = {'key':'value'})\n```\n\nDELETE：删除指定的资源。\n\n```\n>>> r = requests.delete('http://httpbin.org/delete')\n```\n\nCONNECT：建立一个到由目标资源标识的服务器的隧道。\n\nOPTIONS：用于描述目标资源的通信选项。\n\n```\n>>> r = requests.options('http://httpbin.org/get')\n```\n\nTRACE：沿着到目标资源的路径执行一个消息环回测试。\n\nPATCH：用于对资源应用部分修改。\n\nGET和POST对比：\nGET\n1.方法用途\nGET 方法的首要目的是 获取资源\n\n2.方法特点\na) 参数可见\nGET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法\n不过也正是因此，所以 GET 方法允许被保存书签\n\nb) 数据类型只允许 ASCII\nGET 方法的数据类型只允许是 ASCII 字符，所以说传递 二进制 文件就不可以用 GET 方法了哦\n\nc) 可以保存书签\n当我们访问某一个网站的频率特别高的时候，肯定添加到书签，那其实书签就是依靠 GET 方法来保存的\n\nd) 可以被缓存\nGET 方法支持缓存，当本次请求允许被缓存时，会将资源存值本地 cache ，在未过期的情况下直接取本地 cache；缓存过期后视情况而定\n\ne) 参数会保留在浏览器历史记录\n比较直观的感受就是，我们可以在浏览器的历史记录中查看到曾经搜索过的关键字信息\n\nf) 请求长度会受限于所使用的浏览器与服务器\n不同的浏览器对于 GET 请求长度的限制也是不同的，注意这是 浏览器 / 服务器（IE、Chrome、Apache、IIS等） 对于长度的限制，而不是 HTTP 协议\n\nPOST\n1.方法用途\nPOST 方法的首要目的是 提交，POST 方法一般用于添加资源\n\n2.方法特点\na) 参数不可见，也不会被保存\n所以说 POST 方法是不可以被保存书签的\n\nb) 不能收藏为书签\n理由如上\n\nc) 不可以被缓存\n我要提交的数据被缓存在本地 cache 中想想其实也是没道理的\n\nd) 不会被保存在浏览器历史中\n同样是因为参数不可见\n\ne) 不限制请求长度\n对于 POST 方法这种以 提交 为首要目的的方法，肯定是不可以限制请求长度的\n\nf) 数据类型\n不限，所以说 POST 是可以 提交文件 到服务器的\n\ng) 请求方式\nPOST 请求与 GET 请求不同，他会首先提交 HEAD 信息，待得到 100 响应后，才会再次将 DATA 提交\n\n### HTTP协议的组成\n请求报文包含三部分：\n**·**请求行(Request line)：包含请求方法、URI、HTTP版本信息\n**·**请求首部字段(Request header)\n**·**请求内容实体\n响应报文包含三部分：（以豆瓣电影TOP250为例）\n>Request Headers\n\n> GET /top250 HTTP/1.1              \n\\#GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。\nHost: movie.douban.com\n\\#表示请求的域名是movie.douban.com\nConnection: keep-alive\n\\#表示支持长连接\nCache-Control: max-age=0\n\\#指定请求和响应遵循的缓存机制\nUpgrade-Insecure-Requests: 1\n\\#浏览器可以处理https协议\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\n\\#发出请求的用户信息\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\n\\#客户端希望接受的数据类型\nAccept-Encoding: gzip, deflate, br\n\\#浏览器发给服务器,声明浏览器支持的编码类型\nAccept-Language: zh-CN,zh;q=0.9\n\\#浏览器支持的语言分别是简体中文和中文，优先支持简体中文。\nCookie: bid=ZbyUzrJdS2w; __utmc=30149280; __utmc=223695111; __yadk_uid=nTiBvU6fTOaXD90dB6edYhp8urhJwCjc; viewed=\"27599884\"; gr_user_id=4aa3ad30-748f-488c-b5b3-bcff3f0456d4; douban-fav-remind=1; ll=\"118172\"; _vwo_uuid_v2=DE51C937E99B505F3A54AE46B8619B83A|80d039133d473653fabc07636080bbb8; push_noty_num=0; push_doumail_num=0; __utmv=30149280.19454; ap_v=0,6.0; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1554617137%2C%22https%3A%2F%2Fwww.\nbaidu.com%2Flink%3Furl%3Dt8BO_5f8zl_78xcE_dnmyhd_1xbKVsXtXZv_yHxp72UVO88nbOSLQSA1xMPpsfX2%26wd%3\nD%26eqid%3Da8c4f714000c0677000000035ca9932e%22%5D;\n _pk_id.100001.4cf6=e94317b751ae8229.1554384156.13.1554617137.1554583408.; _pk_ses.100001.4cf6=*; __utma=30149280.106710662.1554384144.1554583409.1554617137.12; __utmb=30149280.0.10.1554617137; __utmz=30149280.1554617137.12.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; __utma=223695111.1166551075.1554384156.1554583409.1554617137.13; __utmb=223695111.0.10.1554617137; __utmz=223695111.1554617137.13.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic\n\\#http是无状态的，所以引入了cookie来管理服务器与客户端之间的状态\n\n响应报文包含三部分：\n**·**状态行：包含HTTP版本、状态码、状态码的原因短语\n**·**响应首部字段\n**·**响应内容实体\n> Response header\n\n> HTTP/1.1 200 OK\n\\#响应状态\nDate: Sun, 07 Apr 2019 06:05:45 GMT\n\\#生成消息的具体时间和日期\nContent-Type: text/html; charset=utf-8\n\\#服务器发送 html 文档，字符集为 UTF-8\nTransfer-Encoding: chunked\nConnection: keep-alive\nKeep-Alive: timeout=30\nVary: Accept-Encoding\n\\#服务器响应时根据请求头中的的值返回不同的内容\nX-Xss-Protection: 1; mode=block\n设置浏览器的XSS防护机制，浏览器如果检测到恶意代码，则不渲染恶意代码\nX-Douban-Mobileapp: 0\nExpires: Sun, 1 Jan 2006 01:00:00 GMT\n浏览器会在指定过期时间内使用本地缓存\nPragma: no-cache\nCache-Control: must-revalidate, no-cache, private\nX-DAE-Node: brand4\nX-DAE-App: movie\nServer: dae\nX-Content-Type-Options: nosniff\nContent-Encoding: gzip\n文档使用的 MIME 类型是 text/html，并且对内容进行了 gzip 压缩\n\n### HTTP协议的状态码\n1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。\n2xx （成功） 表示成功处理了请求的状态代码。\n3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\n4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。\n5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。\n常见的：200 – 服务器成功返回网页 |404 – 请求的网页不存在 |503 – 服务不可用 \n\n状态码                     |中文描述 \n:--------------------:|:--------------------:\n100|（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  \n101|（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。\n102|（已接受）已经接受请求，但未处理完成\n200| （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n201|（已创建）  请求成功并且服务器创建了新的资源。\n202|（已接受）  服务器已接受请求，但尚未处理。\n203|（非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204|（无内容）  服务器成功处理了请求，但没有返回任何内容。\n205|（重置内容） 服务器成功处理了请求，但没有返回任何内容。 \n206|（部分内容）  服务器成功处理了部分 GET 请求。\n300|（多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 \n301|（永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n302|（临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n303|（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。\n304|（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 \n305|（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。\n307|（临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n400|（错误请求） 服务器不理解请求的语法。\n401|未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 \n403|（禁止） 服务器拒绝请求。 \n404|（未找到） 服务器找不到请求的网页。 \n405|（方法禁用） 禁用请求中指定的方法。\n406|（不接受） 无法使用请求的内容特性响应请求的网页。 \n407|（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。\n408|（请求超时）  服务器等候请求时发生超时。 \n409|（冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 \n410|（已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 \n411|（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 \n412|（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 \n413|（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 \n414|（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 \n415|（不支持的媒体类型） 请求的格式不受请求页面的支持。 \n416|（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 \n417|（未满足期望值） 服务器未满足”期望”请求标头字段的要求。\n500|（服务器内部错误）  服务器遇到错误，无法完成请求。 \n501|（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。\n502|（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\n503|（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 \n504|（网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 \n505|（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\n  \n  \n<p><image src=\"https://bayuefen.oss-cn-hangzhou.aliyuncs.com/test/44c8b6f9835b1f07ac9bf0e8cb399b16.jpg.source.jpg?x-oss-process=style/compress_high\n\" width=\"400\" align=\"center\"></p>\n\n### cookies和会话\n因为HTTP是无状态的，对事物处理没有记忆能力。cookies和会话出现用于保持HTTP连接状态，\n会话在服务端，用来保存用户的会话信息；cookies在客户端，浏览器下次访问网页时会自动附带上它发送给服务器，\n服务器通过识别cookies找到对应的会话判断用户状态。\nPS:关闭浏览器不会导致会话被删除，反而没有存储到硬盘上的cookie会消失，因此为了节省存储空间需要为会话设置一个失效时间。\n\n假如说我写完了哦。。。\n","slug":"today-is-sunday","published":1,"updated":"2019-04-10T11:07:39.980Z","_id":"cju8garog0001qovljyizibqt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一些学习笔记。<br><a id=\"more\"></a></p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>HTTP协议是客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”全称为“Hyper Text Transfer Protocol”。</p>\n<h3 id=\"HTTP-2协议\"><a href=\"#HTTP-2协议\" class=\"headerlink\" title=\"HTTP/2协议\"></a>HTTP/2协议</h3><p>1、二进制分帧层 (Binary Framing Layer)<br>2、在单个TCP连接里多路复用请求。<br>3、HTTP/2的Server Push，非常重要的一个特性。<br>4、HTTP Header的压缩，采用的是HPack算法。<br>5、应用层的重置连接<br>6、请求优先级设置<br>7、流量控制<br>8、HTTP/1 的几种优化可以弃用<br>参考：<a href=\"https://blog.wangriyu.wang/2018/05-HTTP2.html\" target=\"_blank\" rel=\"noopener\">https://blog.wangriyu.wang/2018/05-HTTP2.html</a></p>\n<h3 id=\"HTTP协议在OSI模型的位置\"><a href=\"#HTTP协议在OSI模型的位置\" class=\"headerlink\" title=\"HTTP协议在OSI模型的位置\"></a>HTTP协议在OSI模型的位置</h3><p>HTTP协议位于应用层<br><img src=\"https://img-blog.csdnimg.cn/20190406164742398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JheXVlZmVuODg2,size_16,color_FFFFFF,t_70\" alt=\"OSI &amp;TCP协议模型对比 \"></p>\n<h3 id=\"HTTP协议的method\"><a href=\"#HTTP协议的method\" class=\"headerlink\" title=\"HTTP协议的method\"></a>HTTP协议的method</h3><p>GET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.get(<span class=\"string\">'https://api.github.com/events'</span>)</span><br></pre></td></tr></table></figure>\n<p>HEAD：请求一个与GET请求的响应相同的响应，但没有响应体.</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.head(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure>\n<p>POST：用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改.<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.post(<span class=\"string\">'http://httpbin.org/post'</span>, data = &#123;<span class=\"string\">'key'</span><span class=\"symbol\">:<span class=\"string\">'value'</span></span>&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>PUT：用请求有效载荷替换目标资源的所有当前表示。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.put(<span class=\"string\">'http://httpbin.org/put'</span>, data = &#123;<span class=\"string\">'key'</span><span class=\"symbol\">:<span class=\"string\">'value'</span></span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>DELETE：删除指定的资源。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.delete(<span class=\"string\">'http://httpbin.org/delete'</span>)</span><br></pre></td></tr></table></figure>\n<p>CONNECT：建立一个到由目标资源标识的服务器的隧道。</p>\n<p>OPTIONS：用于描述目标资源的通信选项。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.options(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure>\n<p>TRACE：沿着到目标资源的路径执行一个消息环回测试。</p>\n<p>PATCH：用于对资源应用部分修改。</p>\n<p>GET和POST对比：<br>GET<br>1.方法用途<br>GET 方法的首要目的是 获取资源</p>\n<p>2.方法特点<br>a) 参数可见<br>GET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法<br>不过也正是因此，所以 GET 方法允许被保存书签</p>\n<p>b) 数据类型只允许 ASCII<br>GET 方法的数据类型只允许是 ASCII 字符，所以说传递 二进制 文件就不可以用 GET 方法了哦</p>\n<p>c) 可以保存书签<br>当我们访问某一个网站的频率特别高的时候，肯定添加到书签，那其实书签就是依靠 GET 方法来保存的</p>\n<p>d) 可以被缓存<br>GET 方法支持缓存，当本次请求允许被缓存时，会将资源存值本地 cache ，在未过期的情况下直接取本地 cache；缓存过期后视情况而定</p>\n<p>e) 参数会保留在浏览器历史记录<br>比较直观的感受就是，我们可以在浏览器的历史记录中查看到曾经搜索过的关键字信息</p>\n<p>f) 请求长度会受限于所使用的浏览器与服务器<br>不同的浏览器对于 GET 请求长度的限制也是不同的，注意这是 浏览器 / 服务器（IE、Chrome、Apache、IIS等） 对于长度的限制，而不是 HTTP 协议</p>\n<p>POST<br>1.方法用途<br>POST 方法的首要目的是 提交，POST 方法一般用于添加资源</p>\n<p>2.方法特点<br>a) 参数不可见，也不会被保存<br>所以说 POST 方法是不可以被保存书签的</p>\n<p>b) 不能收藏为书签<br>理由如上</p>\n<p>c) 不可以被缓存<br>我要提交的数据被缓存在本地 cache 中想想其实也是没道理的</p>\n<p>d) 不会被保存在浏览器历史中<br>同样是因为参数不可见</p>\n<p>e) 不限制请求长度<br>对于 POST 方法这种以 提交 为首要目的的方法，肯定是不可以限制请求长度的</p>\n<p>f) 数据类型<br>不限，所以说 POST 是可以 提交文件 到服务器的</p>\n<p>g) 请求方式<br>POST 请求与 GET 请求不同，他会首先提交 HEAD 信息，待得到 100 响应后，才会再次将 DATA 提交</p>\n<h3 id=\"HTTP协议的组成\"><a href=\"#HTTP协议的组成\" class=\"headerlink\" title=\"HTTP协议的组成\"></a>HTTP协议的组成</h3><p>请求报文包含三部分：<br><strong>·</strong>请求行(Request line)：包含请求方法、URI、HTTP版本信息<br><strong>·</strong>请求首部字段(Request header)<br><strong>·</strong>请求内容实体<br>响应报文包含三部分：（以豆瓣电影TOP250为例）</p>\n<blockquote>\n<p>Request Headers</p>\n</blockquote>\n<blockquote>\n<p>GET /top250 HTTP/1.1<br>#GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。<br>Host: movie.douban.com<br>#表示请求的域名是movie.douban.com<br>Connection: keep-alive<br>#表示支持长连接<br>Cache-Control: max-age=0<br>#指定请求和响应遵循的缓存机制<br>Upgrade-Insecure-Requests: 1<br>#浏览器可以处理https协议<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36<br>#发出请求的用户信息<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3<br>#客户端希望接受的数据类型<br>Accept-Encoding: gzip, deflate, br<br>#浏览器发给服务器,声明浏览器支持的编码类型<br>Accept-Language: zh-CN,zh;q=0.9<br>#浏览器支持的语言分别是简体中文和中文，优先支持简体中文。<br>Cookie: bid=ZbyUzrJdS2w; <strong>utmc=30149280; </strong>utmc=223695111; <strong>yadk_uid=nTiBvU6fTOaXD90dB6edYhp8urhJwCjc; viewed=”27599884”; gr_user_id=4aa3ad30-748f-488c-b5b3-bcff3f0456d4; douban-fav-remind=1; ll=”118172”; _vwo_uuid_v2=DE51C937E99B505F3A54AE46B8619B83A|80d039133d473653fabc07636080bbb8; push_noty_num=0; push_doumail_num=0; </strong>utmv=30149280.19454; ap_v=0,6.0; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1554617137%2C%22https%3A%2F%2Fwww.<br>baidu.com%2Flink%3Furl%3Dt8BO_5f8zl_78xcE_dnmyhd_1xbKVsXtXZv_yHxp72UVO88nbOSLQSA1xMPpsfX2%26wd%3<br>D%26eqid%3Da8c4f714000c0677000000035ca9932e%22%5D;<br> _pk_id.100001.4cf6=e94317b751ae8229.1554384156.13.1554617137.1554583408.; _pk_ses.100001.4cf6=*; <strong>utma=30149280.106710662.1554384144.1554583409.1554617137.12; </strong>utmb=30149280.0.10.1554617137; <strong>utmz=30149280.1554617137.12.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; </strong>utma=223695111.1166551075.1554384156.1554583409.1554617137.13; <strong>utmb=223695111.0.10.1554617137; </strong>utmz=223695111.1554617137.13.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic<br>#http是无状态的，所以引入了cookie来管理服务器与客户端之间的状态</p>\n</blockquote>\n<p>响应报文包含三部分：<br><strong>·</strong>状态行：包含HTTP版本、状态码、状态码的原因短语<br><strong>·</strong>响应首部字段<br><strong>·</strong>响应内容实体</p>\n<blockquote>\n<p>Response header</p>\n</blockquote>\n<blockquote>\n<p>HTTP/1.1 200 OK<br>#响应状态<br>Date: Sun, 07 Apr 2019 06:05:45 GMT<br>#生成消息的具体时间和日期<br>Content-Type: text/html; charset=utf-8<br>#服务器发送 html 文档，字符集为 UTF-8<br>Transfer-Encoding: chunked<br>Connection: keep-alive<br>Keep-Alive: timeout=30<br>Vary: Accept-Encoding<br>#服务器响应时根据请求头中的的值返回不同的内容<br>X-Xss-Protection: 1; mode=block<br>设置浏览器的XSS防护机制，浏览器如果检测到恶意代码，则不渲染恶意代码<br>X-Douban-Mobileapp: 0<br>Expires: Sun, 1 Jan 2006 01:00:00 GMT<br>浏览器会在指定过期时间内使用本地缓存<br>Pragma: no-cache<br>Cache-Control: must-revalidate, no-cache, private<br>X-DAE-Node: brand4<br>X-DAE-App: movie<br>Server: dae<br>X-Content-Type-Options: nosniff<br>Content-Encoding: gzip<br>文档使用的 MIME 类型是 text/html，并且对内容进行了 gzip 压缩</p>\n</blockquote>\n<h3 id=\"HTTP协议的状态码\"><a href=\"#HTTP协议的状态码\" class=\"headerlink\" title=\"HTTP协议的状态码\"></a>HTTP协议的状态码</h3><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。<br>2xx （成功） 表示成功处理了请求的状态代码。<br>3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。<br>4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。<br>5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。<br>常见的：200 – 服务器成功返回网页 |404 – 请求的网页不存在 |503 – 服务不可用 </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">状态码</th>\n<th style=\"text-align:center\">中文描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">101</td>\n<td style=\"text-align:center\">（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">102</td>\n<td style=\"text-align:center\">（已接受）已经接受请求，但未处理完成</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">200</td>\n<td style=\"text-align:center\">（成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">201</td>\n<td style=\"text-align:center\">（已创建）  请求成功并且服务器创建了新的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">202</td>\n<td style=\"text-align:center\">（已接受）  服务器已接受请求，但尚未处理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">203</td>\n<td style=\"text-align:center\">（非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">204</td>\n<td style=\"text-align:center\">（无内容）  服务器成功处理了请求，但没有返回任何内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">205</td>\n<td style=\"text-align:center\">（重置内容） 服务器成功处理了请求，但没有返回任何内容。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">206</td>\n<td style=\"text-align:center\">（部分内容）  服务器成功处理了部分 GET 请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">300</td>\n<td style=\"text-align:center\">（多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">301</td>\n<td style=\"text-align:center\">（永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">302</td>\n<td style=\"text-align:center\">（临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">303</td>\n<td style=\"text-align:center\">（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">304</td>\n<td style=\"text-align:center\">（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">305</td>\n<td style=\"text-align:center\">（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">307</td>\n<td style=\"text-align:center\">（临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">400</td>\n<td style=\"text-align:center\">（错误请求） 服务器不理解请求的语法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">401</td>\n<td style=\"text-align:center\">未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">403</td>\n<td style=\"text-align:center\">（禁止） 服务器拒绝请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">404</td>\n<td style=\"text-align:center\">（未找到） 服务器找不到请求的网页。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">405</td>\n<td style=\"text-align:center\">（方法禁用） 禁用请求中指定的方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">406</td>\n<td style=\"text-align:center\">（不接受） 无法使用请求的内容特性响应请求的网页。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">407</td>\n<td style=\"text-align:center\">（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">408</td>\n<td style=\"text-align:center\">（请求超时）  服务器等候请求时发生超时。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">409</td>\n<td style=\"text-align:center\">（冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">410</td>\n<td style=\"text-align:center\">（已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">411</td>\n<td style=\"text-align:center\">（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">412</td>\n<td style=\"text-align:center\">（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">413</td>\n<td style=\"text-align:center\">（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">414</td>\n<td style=\"text-align:center\">（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">415</td>\n<td style=\"text-align:center\">（不支持的媒体类型） 请求的格式不受请求页面的支持。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">416</td>\n<td style=\"text-align:center\">（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">417</td>\n<td style=\"text-align:center\">（未满足期望值） 服务器未满足”期望”请求标头字段的要求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">（服务器内部错误）  服务器遇到错误，无法完成请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">501</td>\n<td style=\"text-align:center\">（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">502</td>\n<td style=\"text-align:center\">（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">503</td>\n<td style=\"text-align:center\">（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">504</td>\n<td style=\"text-align:center\">（网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">505</td>\n<td style=\"text-align:center\">（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</td>\n</tr>\n</tbody>\n</table>\n<p><image src=\"https://bayuefen.oss-cn-hangzhou.aliyuncs.com/test/44c8b6f9835b1f07ac9bf0e8cb399b16.jpg.source.jpg?x-oss-process=style/compress_high\n\" width=\"400\" align=\"center\"></image></p>\n\n<h3 id=\"cookies和会话\"><a href=\"#cookies和会话\" class=\"headerlink\" title=\"cookies和会话\"></a>cookies和会话</h3><p>因为HTTP是无状态的，对事物处理没有记忆能力。cookies和会话出现用于保持HTTP连接状态，<br>会话在服务端，用来保存用户的会话信息；cookies在客户端，浏览器下次访问网页时会自动附带上它发送给服务器，<br>服务器通过识别cookies找到对应的会话判断用户状态。<br>PS:关闭浏览器不会导致会话被删除，反而没有存储到硬盘上的cookie会消失，因此为了节省存储空间需要为会话设置一个失效时间。</p>\n<p>假如说我写完了哦。。。</p>\n","site":{"data":{}},"excerpt":"<p>一些学习笔记。<br>","more":"</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>HTTP协议是客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”全称为“Hyper Text Transfer Protocol”。</p>\n<h3 id=\"HTTP-2协议\"><a href=\"#HTTP-2协议\" class=\"headerlink\" title=\"HTTP/2协议\"></a>HTTP/2协议</h3><p>1、二进制分帧层 (Binary Framing Layer)<br>2、在单个TCP连接里多路复用请求。<br>3、HTTP/2的Server Push，非常重要的一个特性。<br>4、HTTP Header的压缩，采用的是HPack算法。<br>5、应用层的重置连接<br>6、请求优先级设置<br>7、流量控制<br>8、HTTP/1 的几种优化可以弃用<br>参考：<a href=\"https://blog.wangriyu.wang/2018/05-HTTP2.html\" target=\"_blank\" rel=\"noopener\">https://blog.wangriyu.wang/2018/05-HTTP2.html</a></p>\n<h3 id=\"HTTP协议在OSI模型的位置\"><a href=\"#HTTP协议在OSI模型的位置\" class=\"headerlink\" title=\"HTTP协议在OSI模型的位置\"></a>HTTP协议在OSI模型的位置</h3><p>HTTP协议位于应用层<br><img src=\"https://img-blog.csdnimg.cn/20190406164742398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JheXVlZmVuODg2,size_16,color_FFFFFF,t_70\" alt=\"OSI &amp;TCP协议模型对比 \"></p>\n<h3 id=\"HTTP协议的method\"><a href=\"#HTTP协议的method\" class=\"headerlink\" title=\"HTTP协议的method\"></a>HTTP协议的method</h3><p>GET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.get(<span class=\"string\">'https://api.github.com/events'</span>)</span><br></pre></td></tr></table></figure>\n<p>HEAD：请求一个与GET请求的响应相同的响应，但没有响应体.</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.head(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure>\n<p>POST：用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改.<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.post(<span class=\"string\">'http://httpbin.org/post'</span>, data = &#123;<span class=\"string\">'key'</span><span class=\"symbol\">:<span class=\"string\">'value'</span></span>&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>PUT：用请求有效载荷替换目标资源的所有当前表示。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.put(<span class=\"string\">'http://httpbin.org/put'</span>, data = &#123;<span class=\"string\">'key'</span><span class=\"symbol\">:<span class=\"string\">'value'</span></span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>DELETE：删除指定的资源。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.delete(<span class=\"string\">'http://httpbin.org/delete'</span>)</span><br></pre></td></tr></table></figure>\n<p>CONNECT：建立一个到由目标资源标识的服务器的隧道。</p>\n<p>OPTIONS：用于描述目标资源的通信选项。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.options(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure>\n<p>TRACE：沿着到目标资源的路径执行一个消息环回测试。</p>\n<p>PATCH：用于对资源应用部分修改。</p>\n<p>GET和POST对比：<br>GET<br>1.方法用途<br>GET 方法的首要目的是 获取资源</p>\n<p>2.方法特点<br>a) 参数可见<br>GET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法<br>不过也正是因此，所以 GET 方法允许被保存书签</p>\n<p>b) 数据类型只允许 ASCII<br>GET 方法的数据类型只允许是 ASCII 字符，所以说传递 二进制 文件就不可以用 GET 方法了哦</p>\n<p>c) 可以保存书签<br>当我们访问某一个网站的频率特别高的时候，肯定添加到书签，那其实书签就是依靠 GET 方法来保存的</p>\n<p>d) 可以被缓存<br>GET 方法支持缓存，当本次请求允许被缓存时，会将资源存值本地 cache ，在未过期的情况下直接取本地 cache；缓存过期后视情况而定</p>\n<p>e) 参数会保留在浏览器历史记录<br>比较直观的感受就是，我们可以在浏览器的历史记录中查看到曾经搜索过的关键字信息</p>\n<p>f) 请求长度会受限于所使用的浏览器与服务器<br>不同的浏览器对于 GET 请求长度的限制也是不同的，注意这是 浏览器 / 服务器（IE、Chrome、Apache、IIS等） 对于长度的限制，而不是 HTTP 协议</p>\n<p>POST<br>1.方法用途<br>POST 方法的首要目的是 提交，POST 方法一般用于添加资源</p>\n<p>2.方法特点<br>a) 参数不可见，也不会被保存<br>所以说 POST 方法是不可以被保存书签的</p>\n<p>b) 不能收藏为书签<br>理由如上</p>\n<p>c) 不可以被缓存<br>我要提交的数据被缓存在本地 cache 中想想其实也是没道理的</p>\n<p>d) 不会被保存在浏览器历史中<br>同样是因为参数不可见</p>\n<p>e) 不限制请求长度<br>对于 POST 方法这种以 提交 为首要目的的方法，肯定是不可以限制请求长度的</p>\n<p>f) 数据类型<br>不限，所以说 POST 是可以 提交文件 到服务器的</p>\n<p>g) 请求方式<br>POST 请求与 GET 请求不同，他会首先提交 HEAD 信息，待得到 100 响应后，才会再次将 DATA 提交</p>\n<h3 id=\"HTTP协议的组成\"><a href=\"#HTTP协议的组成\" class=\"headerlink\" title=\"HTTP协议的组成\"></a>HTTP协议的组成</h3><p>请求报文包含三部分：<br><strong>·</strong>请求行(Request line)：包含请求方法、URI、HTTP版本信息<br><strong>·</strong>请求首部字段(Request header)<br><strong>·</strong>请求内容实体<br>响应报文包含三部分：（以豆瓣电影TOP250为例）</p>\n<blockquote>\n<p>Request Headers</p>\n</blockquote>\n<blockquote>\n<p>GET /top250 HTTP/1.1<br>#GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。<br>Host: movie.douban.com<br>#表示请求的域名是movie.douban.com<br>Connection: keep-alive<br>#表示支持长连接<br>Cache-Control: max-age=0<br>#指定请求和响应遵循的缓存机制<br>Upgrade-Insecure-Requests: 1<br>#浏览器可以处理https协议<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36<br>#发出请求的用户信息<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3<br>#客户端希望接受的数据类型<br>Accept-Encoding: gzip, deflate, br<br>#浏览器发给服务器,声明浏览器支持的编码类型<br>Accept-Language: zh-CN,zh;q=0.9<br>#浏览器支持的语言分别是简体中文和中文，优先支持简体中文。<br>Cookie: bid=ZbyUzrJdS2w; <strong>utmc=30149280; </strong>utmc=223695111; <strong>yadk_uid=nTiBvU6fTOaXD90dB6edYhp8urhJwCjc; viewed=”27599884”; gr_user_id=4aa3ad30-748f-488c-b5b3-bcff3f0456d4; douban-fav-remind=1; ll=”118172”; _vwo_uuid_v2=DE51C937E99B505F3A54AE46B8619B83A|80d039133d473653fabc07636080bbb8; push_noty_num=0; push_doumail_num=0; </strong>utmv=30149280.19454; ap_v=0,6.0; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1554617137%2C%22https%3A%2F%2Fwww.<br>baidu.com%2Flink%3Furl%3Dt8BO_5f8zl_78xcE_dnmyhd_1xbKVsXtXZv_yHxp72UVO88nbOSLQSA1xMPpsfX2%26wd%3<br>D%26eqid%3Da8c4f714000c0677000000035ca9932e%22%5D;<br> _pk_id.100001.4cf6=e94317b751ae8229.1554384156.13.1554617137.1554583408.; _pk_ses.100001.4cf6=*; <strong>utma=30149280.106710662.1554384144.1554583409.1554617137.12; </strong>utmb=30149280.0.10.1554617137; <strong>utmz=30149280.1554617137.12.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; </strong>utma=223695111.1166551075.1554384156.1554583409.1554617137.13; <strong>utmb=223695111.0.10.1554617137; </strong>utmz=223695111.1554617137.13.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic<br>#http是无状态的，所以引入了cookie来管理服务器与客户端之间的状态</p>\n</blockquote>\n<p>响应报文包含三部分：<br><strong>·</strong>状态行：包含HTTP版本、状态码、状态码的原因短语<br><strong>·</strong>响应首部字段<br><strong>·</strong>响应内容实体</p>\n<blockquote>\n<p>Response header</p>\n</blockquote>\n<blockquote>\n<p>HTTP/1.1 200 OK<br>#响应状态<br>Date: Sun, 07 Apr 2019 06:05:45 GMT<br>#生成消息的具体时间和日期<br>Content-Type: text/html; charset=utf-8<br>#服务器发送 html 文档，字符集为 UTF-8<br>Transfer-Encoding: chunked<br>Connection: keep-alive<br>Keep-Alive: timeout=30<br>Vary: Accept-Encoding<br>#服务器响应时根据请求头中的的值返回不同的内容<br>X-Xss-Protection: 1; mode=block<br>设置浏览器的XSS防护机制，浏览器如果检测到恶意代码，则不渲染恶意代码<br>X-Douban-Mobileapp: 0<br>Expires: Sun, 1 Jan 2006 01:00:00 GMT<br>浏览器会在指定过期时间内使用本地缓存<br>Pragma: no-cache<br>Cache-Control: must-revalidate, no-cache, private<br>X-DAE-Node: brand4<br>X-DAE-App: movie<br>Server: dae<br>X-Content-Type-Options: nosniff<br>Content-Encoding: gzip<br>文档使用的 MIME 类型是 text/html，并且对内容进行了 gzip 压缩</p>\n</blockquote>\n<h3 id=\"HTTP协议的状态码\"><a href=\"#HTTP协议的状态码\" class=\"headerlink\" title=\"HTTP协议的状态码\"></a>HTTP协议的状态码</h3><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。<br>2xx （成功） 表示成功处理了请求的状态代码。<br>3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。<br>4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。<br>5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。<br>常见的：200 – 服务器成功返回网页 |404 – 请求的网页不存在 |503 – 服务不可用 </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">状态码</th>\n<th style=\"text-align:center\">中文描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">101</td>\n<td style=\"text-align:center\">（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">102</td>\n<td style=\"text-align:center\">（已接受）已经接受请求，但未处理完成</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">200</td>\n<td style=\"text-align:center\">（成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">201</td>\n<td style=\"text-align:center\">（已创建）  请求成功并且服务器创建了新的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">202</td>\n<td style=\"text-align:center\">（已接受）  服务器已接受请求，但尚未处理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">203</td>\n<td style=\"text-align:center\">（非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">204</td>\n<td style=\"text-align:center\">（无内容）  服务器成功处理了请求，但没有返回任何内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">205</td>\n<td style=\"text-align:center\">（重置内容） 服务器成功处理了请求，但没有返回任何内容。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">206</td>\n<td style=\"text-align:center\">（部分内容）  服务器成功处理了部分 GET 请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">300</td>\n<td style=\"text-align:center\">（多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">301</td>\n<td style=\"text-align:center\">（永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">302</td>\n<td style=\"text-align:center\">（临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">303</td>\n<td style=\"text-align:center\">（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">304</td>\n<td style=\"text-align:center\">（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">305</td>\n<td style=\"text-align:center\">（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">307</td>\n<td style=\"text-align:center\">（临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">400</td>\n<td style=\"text-align:center\">（错误请求） 服务器不理解请求的语法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">401</td>\n<td style=\"text-align:center\">未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">403</td>\n<td style=\"text-align:center\">（禁止） 服务器拒绝请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">404</td>\n<td style=\"text-align:center\">（未找到） 服务器找不到请求的网页。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">405</td>\n<td style=\"text-align:center\">（方法禁用） 禁用请求中指定的方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">406</td>\n<td style=\"text-align:center\">（不接受） 无法使用请求的内容特性响应请求的网页。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">407</td>\n<td style=\"text-align:center\">（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">408</td>\n<td style=\"text-align:center\">（请求超时）  服务器等候请求时发生超时。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">409</td>\n<td style=\"text-align:center\">（冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">410</td>\n<td style=\"text-align:center\">（已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">411</td>\n<td style=\"text-align:center\">（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">412</td>\n<td style=\"text-align:center\">（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">413</td>\n<td style=\"text-align:center\">（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">414</td>\n<td style=\"text-align:center\">（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">415</td>\n<td style=\"text-align:center\">（不支持的媒体类型） 请求的格式不受请求页面的支持。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">416</td>\n<td style=\"text-align:center\">（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">417</td>\n<td style=\"text-align:center\">（未满足期望值） 服务器未满足”期望”请求标头字段的要求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">（服务器内部错误）  服务器遇到错误，无法完成请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">501</td>\n<td style=\"text-align:center\">（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">502</td>\n<td style=\"text-align:center\">（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">503</td>\n<td style=\"text-align:center\">（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">504</td>\n<td style=\"text-align:center\">（网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">505</td>\n<td style=\"text-align:center\">（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</td>\n</tr>\n</tbody>\n</table>\n<p><image src=\"https://bayuefen.oss-cn-hangzhou.aliyuncs.com/test/44c8b6f9835b1f07ac9bf0e8cb399b16.jpg.source.jpg?x-oss-process=style/compress_high\n\" width=\"400\" align=\"center\"></image></p>\n\n<h3 id=\"cookies和会话\"><a href=\"#cookies和会话\" class=\"headerlink\" title=\"cookies和会话\"></a>cookies和会话</h3><p>因为HTTP是无状态的，对事物处理没有记忆能力。cookies和会话出现用于保持HTTP连接状态，<br>会话在服务端，用来保存用户的会话信息；cookies在客户端，浏览器下次访问网页时会自动附带上它发送给服务器，<br>服务器通过识别cookies找到对应的会话判断用户状态。<br>PS:关闭浏览器不会导致会话被删除，反而没有存储到硬盘上的cookie会消失，因此为了节省存储空间需要为会话设置一个失效时间。</p>\n<p>假如说我写完了哦。。。</p>"},{"title":"辨析 Sass 中的 Map 和 List","date":"2015-10-21T02:34:12.000Z","_content":"\n如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。\n\n自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。\n\n那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 `package.json` 或者其他同类型的项目配置文件所控制，往往只需一条命令（`gem update sass`）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。\n\n<!-- more -->\n\n使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。\n\n## 测试表格\n\nVariable | Description\n--- | ---\n`site` | Sitewide information.\n`page` | Page specific information and custom variables set in front-matter.\n`config` | Site configuration\n`theme` | Theme configuration. Inherits from site configuration.\n`_` (single underscore) | [Lodash](http://lodash.com/) library\n`path` | Path of current page\n`url` | Full URL of current page\n`env` | Environment variables\n\n\n## 语法比较\n\n<div class=\"note\">\n    <h5>测试标题</h5>\n    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p>\n</div>\n\n#### Map 语法\n\n下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。\n\n```sass\n$breakpoint-map: (\n    small: (\n        min-width: null,\n        max-width: 479px,\n        base-font: 16px,\n        vertical-rhythm: 1.3\n    ),\n    medium: (\n        min-width: 480px,\n        max-width: 959px,\n        base-font: 18px,\n        vertical-rhythm: 1.414\n    ),\n    large: (\n        min-width: 960px,\n        max-width: 1099px,\n        base-font: 18px,\n        vertical-rhythm: 1.5\n    ),\n    xlarge: (\n        min-width: 1100px,\n        max-width: null,\n        base-font: 21px,\n        vertical-rhythm: 1.618\n    )\n);\n```\n\n#### 多重列表语法\n\n下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 `nth()` 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, null, 21px, 1.618)\n);\n```\n\n## 遍历比较\n\n<div class=\"note info\">\n    <h5>测试标题</h5>\n    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p>\n</div>\n\n#### 遍历 Map\n\n我们可以使用如下的代码遍历 Map：\n\n```sass\n@each $label, $map in $breakpoint-map {}\n```\n\n这里的变量 `$label` 和 `$map` 会随着对 `$breakpoint-map` 的遍历被动态地赋值，`$label` 将会被赋值为 `$breakpoint-map` 的 Key，而 `$map` 会被赋值为 `$breakpoint-map` 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 `map-get()` 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。\n\n具体的做法就是使用 `@each` 遍历 Map，然后使用 `map-get()` 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：\n\n```sass\n@each $label, $map in $breakpoint-map {\n    $min-width: map-get($map, min-width);\n    $max-width: map-get($map, max-width);\n    $base-font: map-get($map, base-font);\n    $vertical-rhythm: map-get($map, vertical-rhythm);\n}\n```\n\n#### 遍历多重列表\n\n遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 `map-get()` 函数取特定值，直接遍历一遍即可获得特定值。\n\n因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 `map-get()`，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：\n\n```sass\n@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n}\n```\n\n## 慎用多重列表\n\n<div class=\"note warning\">\n    <h5>测试标题</h5>\n    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p>\n</div>\n\n#### 遗漏键值\n\n如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, 21px, 1.618)\n);\n\np {\n    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n        @if $min-width {\n            @include breakpoint( $min-width ) {\n                font-size: $base-font;\n                line-height: $vertical-rhythm;\n            }\n        } @else {\n            font-size: $base-font;\n            line-height: $vertical-rhythm;\n        }\n    }\n}\n```\n\n当我们尝试运行这段代码时，结果肯定是错误地，因为在 `$breakpoint-list` 的最后一行，`xlarge` 被赋值给了 `$label`，`1100px` 被赋值给了 `$min-width`，`21px` 被赋值给了 `$max-width`, `1.618` 被赋值给了 `$base-font`，最终导致 `$vertical-rhythm` 没有被赋值，结果就是 `font-size` 的属性值是错的，`line-height` 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。\n\n如果我们使用 Map 来代替这里的多重列表，那么使用 `map-get()` 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。\n\n#### 查找特定列表\n\n在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 `map-get()` 函数可以快速定位到特定子 Map：\n\n```sass\n$medium-map: map-get($maps, medium);\n```\n\n但如果要获取多种列表 `medium` 列表，麻烦可就大了：\n\n```sass\n@function get-list($label) {\n    @each $list in $breakpoint-list {\n        @if nth($list, 1) == $label {\n            @return $list;\n        }\n    }\n    @return null;\n}\n$medium-list: get-list(medium);\n```\n\n这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 `null`。这实际上就是手工实现了 `map-get()` 的逻辑。\n\n#### 缺少原生的 Map 函数\n\nSass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 `map-merge()` 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 `join()` 或 `append()` 来增加新列表，从而模拟出 `map-merge()` 的效果。\n\n另一个实用的 Map 函数就是 `map-has-key()`，对于依赖 `map-get()` 的自定义函数来说，`map-has-key()` 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。\n\n## 总结\n\n<div class=\"note unreleased\">\n    <h5>Test Title</h5>\n    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p>\n</div>\n\n虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。\n","source":"_posts/demo.md","raw":"title: 辨析 Sass 中的 Map 和 List\ndate: 2015-10-21 10:34:12\ntags:\n- css\n---\n\n如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。\n\n自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。\n\n那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 `package.json` 或者其他同类型的项目配置文件所控制，往往只需一条命令（`gem update sass`）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。\n\n<!-- more -->\n\n使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。\n\n## 测试表格\n\nVariable | Description\n--- | ---\n`site` | Sitewide information.\n`page` | Page specific information and custom variables set in front-matter.\n`config` | Site configuration\n`theme` | Theme configuration. Inherits from site configuration.\n`_` (single underscore) | [Lodash](http://lodash.com/) library\n`path` | Path of current page\n`url` | Full URL of current page\n`env` | Environment variables\n\n\n## 语法比较\n\n<div class=\"note\">\n    <h5>测试标题</h5>\n    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p>\n</div>\n\n#### Map 语法\n\n下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。\n\n```sass\n$breakpoint-map: (\n    small: (\n        min-width: null,\n        max-width: 479px,\n        base-font: 16px,\n        vertical-rhythm: 1.3\n    ),\n    medium: (\n        min-width: 480px,\n        max-width: 959px,\n        base-font: 18px,\n        vertical-rhythm: 1.414\n    ),\n    large: (\n        min-width: 960px,\n        max-width: 1099px,\n        base-font: 18px,\n        vertical-rhythm: 1.5\n    ),\n    xlarge: (\n        min-width: 1100px,\n        max-width: null,\n        base-font: 21px,\n        vertical-rhythm: 1.618\n    )\n);\n```\n\n#### 多重列表语法\n\n下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 `nth()` 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, null, 21px, 1.618)\n);\n```\n\n## 遍历比较\n\n<div class=\"note info\">\n    <h5>测试标题</h5>\n    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p>\n</div>\n\n#### 遍历 Map\n\n我们可以使用如下的代码遍历 Map：\n\n```sass\n@each $label, $map in $breakpoint-map {}\n```\n\n这里的变量 `$label` 和 `$map` 会随着对 `$breakpoint-map` 的遍历被动态地赋值，`$label` 将会被赋值为 `$breakpoint-map` 的 Key，而 `$map` 会被赋值为 `$breakpoint-map` 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 `map-get()` 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。\n\n具体的做法就是使用 `@each` 遍历 Map，然后使用 `map-get()` 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：\n\n```sass\n@each $label, $map in $breakpoint-map {\n    $min-width: map-get($map, min-width);\n    $max-width: map-get($map, max-width);\n    $base-font: map-get($map, base-font);\n    $vertical-rhythm: map-get($map, vertical-rhythm);\n}\n```\n\n#### 遍历多重列表\n\n遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 `map-get()` 函数取特定值，直接遍历一遍即可获得特定值。\n\n因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 `map-get()`，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：\n\n```sass\n@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n}\n```\n\n## 慎用多重列表\n\n<div class=\"note warning\">\n    <h5>测试标题</h5>\n    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p>\n</div>\n\n#### 遗漏键值\n\n如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, 21px, 1.618)\n);\n\np {\n    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n        @if $min-width {\n            @include breakpoint( $min-width ) {\n                font-size: $base-font;\n                line-height: $vertical-rhythm;\n            }\n        } @else {\n            font-size: $base-font;\n            line-height: $vertical-rhythm;\n        }\n    }\n}\n```\n\n当我们尝试运行这段代码时，结果肯定是错误地，因为在 `$breakpoint-list` 的最后一行，`xlarge` 被赋值给了 `$label`，`1100px` 被赋值给了 `$min-width`，`21px` 被赋值给了 `$max-width`, `1.618` 被赋值给了 `$base-font`，最终导致 `$vertical-rhythm` 没有被赋值，结果就是 `font-size` 的属性值是错的，`line-height` 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。\n\n如果我们使用 Map 来代替这里的多重列表，那么使用 `map-get()` 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。\n\n#### 查找特定列表\n\n在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 `map-get()` 函数可以快速定位到特定子 Map：\n\n```sass\n$medium-map: map-get($maps, medium);\n```\n\n但如果要获取多种列表 `medium` 列表，麻烦可就大了：\n\n```sass\n@function get-list($label) {\n    @each $list in $breakpoint-list {\n        @if nth($list, 1) == $label {\n            @return $list;\n        }\n    }\n    @return null;\n}\n$medium-list: get-list(medium);\n```\n\n这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 `null`。这实际上就是手工实现了 `map-get()` 的逻辑。\n\n#### 缺少原生的 Map 函数\n\nSass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 `map-merge()` 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 `join()` 或 `append()` 来增加新列表，从而模拟出 `map-merge()` 的效果。\n\n另一个实用的 Map 函数就是 `map-has-key()`，对于依赖 `map-get()` 的自定义函数来说，`map-has-key()` 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。\n\n## 总结\n\n<div class=\"note unreleased\">\n    <h5>Test Title</h5>\n    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p>\n</div>\n\n虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。\n","slug":"demo","published":1,"updated":"2019-04-08T13:41:38.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju8garoo000aqovlmavugb75","content":"<p>如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。</p>\n<p>自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。</p>\n<p>那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 <code>package.json</code> 或者其他同类型的项目配置文件所控制，往往只需一条命令（<code>gem update sass</code>）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。</p>\n<a id=\"more\"></a>\n<p>使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。</p>\n<h2 id=\"测试表格\"><a href=\"#测试表格\" class=\"headerlink\" title=\"测试表格\"></a>测试表格</h2><table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>site</code></td>\n<td>Sitewide information.</td>\n</tr>\n<tr>\n<td><code>page</code></td>\n<td>Page specific information and custom variables set in front-matter.</td>\n</tr>\n<tr>\n<td><code>config</code></td>\n<td>Site configuration</td>\n</tr>\n<tr>\n<td><code>theme</code></td>\n<td>Theme configuration. Inherits from site configuration.</td>\n</tr>\n<tr>\n<td><code>_</code> (single underscore)</td>\n<td><a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a> library</td>\n</tr>\n<tr>\n<td><code>path</code></td>\n<td>Path of current page</td>\n</tr>\n<tr>\n<td><code>url</code></td>\n<td>Full URL of current page</td>\n</tr>\n<tr>\n<td><code>env</code></td>\n<td>Environment variables</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"语法比较\"><a href=\"#语法比较\" class=\"headerlink\" title=\"语法比较\"></a>语法比较</h2><div class=\"note\"><br>    <h5>测试标题</h5><br>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 <code>min-width</code>、<code>max-width</code>、<code>font-size</code> 和 <code>line-height</code> 四个样式。</p><br></div>\n\n<h4 id=\"Map-语法\"><a href=\"#Map-语法\" class=\"headerlink\" title=\"Map 语法\"></a>Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-map: (</span><br><span class=\"line\">    small: (</span><br><span class=\"line\">        min-width: null,</span><br><span class=\"line\">        max-width: 479px,</span><br><span class=\"line\">        base-font: 16px,</span><br><span class=\"line\">        vertical-rhythm: 1.3</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    medium: (</span><br><span class=\"line\">        min-width: 480px,</span><br><span class=\"line\">        max-width: 959px,</span><br><span class=\"line\">        base-font: 18px,</span><br><span class=\"line\">        vertical-rhythm: 1.414</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    large: (</span><br><span class=\"line\">        min-width: 960px,</span><br><span class=\"line\">        max-width: 1099px,</span><br><span class=\"line\">        base-font: 18px,</span><br><span class=\"line\">        vertical-rhythm: 1.5</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    xlarge: (</span><br><span class=\"line\">        min-width: 1100px,</span><br><span class=\"line\">        max-width: null,</span><br><span class=\"line\">        base-font: 21px,</span><br><span class=\"line\">        vertical-rhythm: 1.618</span><br><span class=\"line\">    )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"多重列表语法\"><a href=\"#多重列表语法\" class=\"headerlink\" title=\"多重列表语法\"></a>多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-list: (</span><br><span class=\"line\">    (small, null, 479px, 16px, 1.3),</span><br><span class=\"line\">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class=\"line\">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class=\"line\">    (xlarge, 1100px, null, 21px, 1.618)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历比较\"><a href=\"#遍历比较\" class=\"headerlink\" title=\"遍历比较\"></a>遍历比较</h2><div class=\"note info\"><br>    <h5>测试标题</h5><br>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p><br></div>\n\n<h4 id=\"遍历-Map\"><a href=\"#遍历-Map\" class=\"headerlink\" title=\"遍历 Map\"></a>遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $map in $breakpoint-map &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p>\n<p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $map in $breakpoint-map &#123;</span><br><span class=\"line\">    $min-width: map-get($map, min-width);</span><br><span class=\"line\">    $max-width: map-get($map, max-width);</span><br><span class=\"line\">    $base-font: map-get($map, base-font);</span><br><span class=\"line\">    $vertical-rhythm: map-get($map, vertical-rhythm);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"遍历多重列表\"><a href=\"#遍历多重列表\" class=\"headerlink\" title=\"遍历多重列表\"></a>遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p>\n<p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"慎用多重列表\"><a href=\"#慎用多重列表\" class=\"headerlink\" title=\"慎用多重列表\"></a>慎用多重列表</h2><div class=\"note warning\"><br>    <h5>测试标题</h5><br>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p><br></div>\n\n<h4 id=\"遗漏键值\"><a href=\"#遗漏键值\" class=\"headerlink\" title=\"遗漏键值\"></a>遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-list: (</span><br><span class=\"line\">    (small, null, 479px, 16px, 1.3),</span><br><span class=\"line\">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class=\"line\">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class=\"line\">    (xlarge, 1100px, 21px, 1.618)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">p &#123;</span><br><span class=\"line\">    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class=\"line\">        @if $min-width &#123;</span><br><span class=\"line\">            @include breakpoint( $min-width ) &#123;</span><br><span class=\"line\">                font-size: $base-font;</span><br><span class=\"line\">                line-height: $vertical-rhythm;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; @else &#123;</span><br><span class=\"line\">            font-size: $base-font;</span><br><span class=\"line\">            line-height: $vertical-rhythm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p>\n<p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p>\n<h4 id=\"查找特定列表\"><a href=\"#查找特定列表\" class=\"headerlink\" title=\"查找特定列表\"></a>查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$medium-map: map-get($maps, medium);</span><br></pre></td></tr></table></figure>\n<p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function get-list($label) &#123;</span><br><span class=\"line\">    @each $list in $breakpoint-list &#123;</span><br><span class=\"line\">        @if nth($list, 1) == $label &#123;</span><br><span class=\"line\">            @return $list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$medium-list: get-list(medium);</span><br></pre></td></tr></table></figure>\n<p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p>\n<h4 id=\"缺少原生的-Map-函数\"><a href=\"#缺少原生的-Map-函数\" class=\"headerlink\" title=\"缺少原生的 Map 函数\"></a>缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p>\n<p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><div class=\"note unreleased\"><br>    <h5>Test Title</h5><br>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p><br></div>\n\n<p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>\n","site":{"data":{}},"excerpt":"<p>如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。</p>\n<p>自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。</p>\n<p>那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 <code>package.json</code> 或者其他同类型的项目配置文件所控制，往往只需一条命令（<code>gem update sass</code>）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。</p>","more":"<p>使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。</p>\n<h2 id=\"测试表格\"><a href=\"#测试表格\" class=\"headerlink\" title=\"测试表格\"></a>测试表格</h2><table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>site</code></td>\n<td>Sitewide information.</td>\n</tr>\n<tr>\n<td><code>page</code></td>\n<td>Page specific information and custom variables set in front-matter.</td>\n</tr>\n<tr>\n<td><code>config</code></td>\n<td>Site configuration</td>\n</tr>\n<tr>\n<td><code>theme</code></td>\n<td>Theme configuration. Inherits from site configuration.</td>\n</tr>\n<tr>\n<td><code>_</code> (single underscore)</td>\n<td><a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a> library</td>\n</tr>\n<tr>\n<td><code>path</code></td>\n<td>Path of current page</td>\n</tr>\n<tr>\n<td><code>url</code></td>\n<td>Full URL of current page</td>\n</tr>\n<tr>\n<td><code>env</code></td>\n<td>Environment variables</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"语法比较\"><a href=\"#语法比较\" class=\"headerlink\" title=\"语法比较\"></a>语法比较</h2><div class=\"note\"><br>    <h5>测试标题</h5><br>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 <code>min-width</code>、<code>max-width</code>、<code>font-size</code> 和 <code>line-height</code> 四个样式。</p><br></div>\n\n<h4 id=\"Map-语法\"><a href=\"#Map-语法\" class=\"headerlink\" title=\"Map 语法\"></a>Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-map: (</span><br><span class=\"line\">    small: (</span><br><span class=\"line\">        min-width: null,</span><br><span class=\"line\">        max-width: 479px,</span><br><span class=\"line\">        base-font: 16px,</span><br><span class=\"line\">        vertical-rhythm: 1.3</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    medium: (</span><br><span class=\"line\">        min-width: 480px,</span><br><span class=\"line\">        max-width: 959px,</span><br><span class=\"line\">        base-font: 18px,</span><br><span class=\"line\">        vertical-rhythm: 1.414</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    large: (</span><br><span class=\"line\">        min-width: 960px,</span><br><span class=\"line\">        max-width: 1099px,</span><br><span class=\"line\">        base-font: 18px,</span><br><span class=\"line\">        vertical-rhythm: 1.5</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    xlarge: (</span><br><span class=\"line\">        min-width: 1100px,</span><br><span class=\"line\">        max-width: null,</span><br><span class=\"line\">        base-font: 21px,</span><br><span class=\"line\">        vertical-rhythm: 1.618</span><br><span class=\"line\">    )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"多重列表语法\"><a href=\"#多重列表语法\" class=\"headerlink\" title=\"多重列表语法\"></a>多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-list: (</span><br><span class=\"line\">    (small, null, 479px, 16px, 1.3),</span><br><span class=\"line\">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class=\"line\">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class=\"line\">    (xlarge, 1100px, null, 21px, 1.618)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历比较\"><a href=\"#遍历比较\" class=\"headerlink\" title=\"遍历比较\"></a>遍历比较</h2><div class=\"note info\"><br>    <h5>测试标题</h5><br>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p><br></div>\n\n<h4 id=\"遍历-Map\"><a href=\"#遍历-Map\" class=\"headerlink\" title=\"遍历 Map\"></a>遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $map in $breakpoint-map &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p>\n<p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $map in $breakpoint-map &#123;</span><br><span class=\"line\">    $min-width: map-get($map, min-width);</span><br><span class=\"line\">    $max-width: map-get($map, max-width);</span><br><span class=\"line\">    $base-font: map-get($map, base-font);</span><br><span class=\"line\">    $vertical-rhythm: map-get($map, vertical-rhythm);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"遍历多重列表\"><a href=\"#遍历多重列表\" class=\"headerlink\" title=\"遍历多重列表\"></a>遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p>\n<p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"慎用多重列表\"><a href=\"#慎用多重列表\" class=\"headerlink\" title=\"慎用多重列表\"></a>慎用多重列表</h2><div class=\"note warning\"><br>    <h5>测试标题</h5><br>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p><br></div>\n\n<h4 id=\"遗漏键值\"><a href=\"#遗漏键值\" class=\"headerlink\" title=\"遗漏键值\"></a>遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-list: (</span><br><span class=\"line\">    (small, null, 479px, 16px, 1.3),</span><br><span class=\"line\">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class=\"line\">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class=\"line\">    (xlarge, 1100px, 21px, 1.618)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">p &#123;</span><br><span class=\"line\">    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class=\"line\">        @if $min-width &#123;</span><br><span class=\"line\">            @include breakpoint( $min-width ) &#123;</span><br><span class=\"line\">                font-size: $base-font;</span><br><span class=\"line\">                line-height: $vertical-rhythm;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; @else &#123;</span><br><span class=\"line\">            font-size: $base-font;</span><br><span class=\"line\">            line-height: $vertical-rhythm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p>\n<p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p>\n<h4 id=\"查找特定列表\"><a href=\"#查找特定列表\" class=\"headerlink\" title=\"查找特定列表\"></a>查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$medium-map: map-get($maps, medium);</span><br></pre></td></tr></table></figure>\n<p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function get-list($label) &#123;</span><br><span class=\"line\">    @each $list in $breakpoint-list &#123;</span><br><span class=\"line\">        @if nth($list, 1) == $label &#123;</span><br><span class=\"line\">            @return $list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$medium-list: get-list(medium);</span><br></pre></td></tr></table></figure>\n<p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p>\n<h4 id=\"缺少原生的-Map-函数\"><a href=\"#缺少原生的-Map-函数\" class=\"headerlink\" title=\"缺少原生的 Map 函数\"></a>缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p>\n<p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><div class=\"note unreleased\"><br>    <h5>Test Title</h5><br>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p><br></div>\n\n<p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cju8garob0000qovlrvz3byax","tag_id":"cju8garoi0002qovlcx21qiud","_id":"cju8garol0005qovlvf4aake8"},{"post_id":"cju8garob0000qovlrvz3byax","tag_id":"cju8garok0003qovlnd8uzqcc","_id":"cju8garol0006qovl6ezzzq8c"},{"post_id":"cju8garog0001qovljyizibqt","tag_id":"cju8garok0004qovl7k0d8jhc","_id":"cju8garom0008qovlzqx5h56x"},{"post_id":"cju8garoo000aqovlmavugb75","tag_id":"cju8garoq000bqovlkzq2rf8t","_id":"cju8garor000cqovl9lcxxkjj"},{"post_id":"cju8garog0001qovljyizibqt","tag_id":"cju9plspg0000f8vlooijnzzj","_id":"cju9plspj0001f8vlpv66xeld"}],"Tag":[{"name":"标签1","_id":"cju8garoi0002qovlcx21qiud"},{"name":"测试标签","_id":"cju8garok0003qovlnd8uzqcc"},{"name":"日记","_id":"cju8garok0004qovl7k0d8jhc"},{"name":"生活琐事","_id":"cju8garol0007qovlvuylsonv"},{"name":"css","_id":"cju8garoq000bqovlkzq2rf8t"},{"name":"学习Vlog","_id":"cju9plspg0000f8vlooijnzzj"}]}}