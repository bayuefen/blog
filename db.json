{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"source/assets/image/favicon.ico","path":"assets/image/favicon.ico","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"source/assets/image/avator.jpeg","path":"assets/image/avator.jpeg","modified":0,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"source/assets/blog/totoro.jpeg","path":"assets/blog/totoro.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"3fee08611be222bf96c7407daa291a468ba0f344","modified":1554697600000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1554618463000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1554618463000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1554618463000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1554618463000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1554618463000},{"_id":"themes/yilia/_config.yml","hash":"3cf05539ee432af68dab1748b2d5a48b4e47acd7","modified":1554883926000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1554618463000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1554618463000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1554618463000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1554618463000},{"_id":"source/_posts/python-lib-unittest.md","hash":"42f2b5fa99f38bbf383fb0c79b114d445c0a8e44","modified":1555506610000},{"_id":"source/_posts/node-server-deploy.md","hash":"b8863837f2902d67891ab439a5020da399c2dd05","modified":1555860624000},{"_id":"source/_posts/http-learn-notes.md","hash":"dbbec16470850bceeaec5f95c16bf003d86bcc51","modified":1555558539000},{"_id":"source/_posts/demo.md","hash":"b236aa0ab34c2135b61e54dacd47ca3de1f2eb6a","modified":1554615920000},{"_id":"source/assets/.DS_Store","hash":"876f7f947a983a8df6e73cf936b2116b9ce0a001","modified":1554697600000},{"_id":"source/_posts/python-module-requests.md","hash":"97cb04088e975498e5d8d4b6e8c1f049de376ac9","modified":1555486172000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1554618463000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1554618463000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1554618463000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1554618463000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1554618463000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1554618463000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1554618463000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1554618463000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1554618463000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1554618463000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1554618463000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1554618463000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1554618463000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1554618463000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1554618463000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1554618463000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1554618463000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1554618463000},{"_id":"source/assets/image/favicon.ico","hash":"c7dcd652fa9ed927d0ec2e0580f5de1ae9ddbdff","modified":1519735414000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1554618463000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"5299bd43c93dabe6eacb96ae9f83271c49c5909d","modified":1554698378000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1554618463000},{"_id":"source/assets/image/avator.jpeg","hash":"614f22cdbeb97afe962d213915c1cf65e3a2c237","modified":1554619462000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1554618463000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1554618463000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1554618463000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1554618463000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1554618463000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1554618463000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1554618463000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1554618463000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1554618463000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1554618463000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1554618463000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1554618463000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1554618463000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1554618463000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1554618463000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1554618463000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1554618463000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1554618463000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1554618463000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1554618463000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1554618463000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1554618463000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1554618463000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1554618463000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1554618463000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1554618463000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1554618463000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1554618463000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1554618463000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1554618463000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1554618463000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1554618463000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1554618463000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1554618463000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1554618463000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1554618463000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1554618463000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1554618463000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1554618463000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1554618463000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1554618463000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1554618463000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1554618463000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1554618463000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1554618463000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1554618463000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1554618463000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1554618463000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1554618463000},{"_id":"source/assets/blog/totoro.jpeg","hash":"30bc504edb2e9bd4ef8a4e2321f0d0f4c8283a91","modified":1554622101000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1554618463000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1554618463000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1554618463000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1554618463000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1554618463000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1554618463000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1554618463000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1554618463000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1554618463000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1554618463000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1554618463000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1554618463000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1554618463000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1554618463000},{"_id":"public/atom.xml","hash":"631d95e20fc3d138de755bba085fc6fe7dba2f1f","modified":1555861759264},{"_id":"public/content.json","hash":"856072f45d6486d53f2077c3bf59e2708f01db11","modified":1555860761968},{"_id":"public/2019/04/17/python-lib-unittest/index.html","hash":"b5045291e6ae255e29e3da0e62b9601afe8baf4d","modified":1555861760379},{"_id":"public/2019/04/17/python-module-requests/index.html","hash":"da6e9d209e40ff8e3bd22af93528e6168e571b8c","modified":1555861760379},{"_id":"public/2019/04/09/http-learn-notes/index.html","hash":"110c07d24c59d76976ea97e9258577754fd1eea5","modified":1555861760379},{"_id":"public/2015/10/21/demo/index.html","hash":"9efcdc76a476550152df9c0d6b4e096696f707f7","modified":1555861760380},{"_id":"public/archives/index.html","hash":"bee501987ab5c480b0efa4e18af933a16b96e419","modified":1555861760380},{"_id":"public/archives/2015/index.html","hash":"16b38bdf4bf349a3ccce1de31ed5886ca1527764","modified":1555861760380},{"_id":"public/archives/2015/10/index.html","hash":"bc113ce23c9342681ce73a15076a2bddf339daec","modified":1555861760380},{"_id":"public/archives/2019/index.html","hash":"d9110427ae9175988ef5ff2a953958627b54b39d","modified":1555861760380},{"_id":"public/archives/2019/04/index.html","hash":"966a0fe9878a16962b32df92d87ca70254d5ec82","modified":1555861760380},{"_id":"public/index.html","hash":"7fc95c7156e3aa6ae0e8930c987c3878c74976a9","modified":1555861760382},{"_id":"public/tags/python/index.html","hash":"18ccdab6ec09e0568a5195297577de1d00e04f67","modified":1555861760380},{"_id":"public/tags/unittest/index.html","hash":"6b6d9f33b5e4786a25385104e263fc5e54893497","modified":1555861760381},{"_id":"public/tags/日记/index.html","hash":"4420b6f143b3ed6f2484149ad177bee62f5b97aa","modified":1555861760381},{"_id":"public/tags/HTTP/index.html","hash":"9f88b929189fd603ec5227239a8cffffe86321c2","modified":1555861760381},{"_id":"public/tags/学习Vlog/index.html","hash":"fe036a60973bcd7c90f32508666ce0b5cd8bf19a","modified":1555861760381},{"_id":"public/tags/css/index.html","hash":"d5844dceb9c4e363ce6eac18ffe0e68e929e6d56","modified":1555861760381},{"_id":"public/tags/requests/index.html","hash":"1619484e54692e5774994bf898045f0195afdaec","modified":1555861760381},{"_id":"public/2019/04/19/node-server-deploy/index.html","hash":"070751f8299f00f941d5ba1d8642891f22e0c9e5","modified":1555861760379},{"_id":"public/tags/Node/index.html","hash":"8bd519427bc24ec31a822057659386cdb7faf1b7","modified":1555861760381},{"_id":"public/tags/MongoDB/index.html","hash":"5a32a44af98c0cd87176245c4416dd357aaab323","modified":1555861760381},{"_id":"public/tags/服务部署/index.html","hash":"30c92405ffbab3710f99294b06c03bc9a796ef98","modified":1555861760381}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"【python】标准库unittest基本应用","date":"2019-04-17T09:36:29.000Z","_content":"\n[`unittest`](https://docs.python.org/3.7/library/unittest.html)的入门基本应用记录。\n\n概念\n`unittest`是`python`自带的标准库之一，是`python`版的`junit`，主要用于维护执行自动化测试框架的用例。\n\n<!-- more -->\n\n## 核心工作原理\n核心应有有：`TestCase` `TestSuite` `TestLoader` `TestRunner` `TestFixture` 等构造函数。\n\n- `TestCase`: 测试用例。一个完整的测试单元包括 测试前准备环境的搭建(`setUp`)，执行测试代码(`run`)，以及测试后环境的还原(`tearDown`)。一系列具有完整测试流程的测试单元组成测试用例。\n- `TestSuite`: 测试用例合集。多个`TestCase`集合组成`TestSuite`。且`TestSuite`可以嵌套其他`TestSuite`。\n- `TestLoader`: 测试用例装载器。主要用于加载`TestCase`值`TestSuite`。通过`loadTestsFrom__()`方法加载`TestCase`，并创建其实例，然后将该实例添加至`TestSuite`中，返回`TestSuite`实例。\n- `TestRunner`: 测试用例执行器。执行器中的`run(test)`方法会自动执行`TestCase`、`TestSuite`中的`run(result)`方法，并将执行的测试结果保存至`TextTestResult`实例中，用于统计测试用例执行结果合计。\n- `TestFixture`: 测试环境构建与销毁维护。在测试用例运行初始化前使用`setUp()`准备初始环境，在测试用例执行完毕后使用`tearDown()`执行销毁，还原运行测试环境。\n\n\n参考链接\n\nhttps://blog.csdn.net/luanpeng825485697/article/details/79459771\n\n","source":"_posts/python-lib-unittest.md","raw":"---\ntitle: 【python】标准库unittest基本应用\ndate: 2019-04-17 17:36:29\ntags:\n    - python\n    - unittest\n    - 日记\n---\n\n[`unittest`](https://docs.python.org/3.7/library/unittest.html)的入门基本应用记录。\n\n概念\n`unittest`是`python`自带的标准库之一，是`python`版的`junit`，主要用于维护执行自动化测试框架的用例。\n\n<!-- more -->\n\n## 核心工作原理\n核心应有有：`TestCase` `TestSuite` `TestLoader` `TestRunner` `TestFixture` 等构造函数。\n\n- `TestCase`: 测试用例。一个完整的测试单元包括 测试前准备环境的搭建(`setUp`)，执行测试代码(`run`)，以及测试后环境的还原(`tearDown`)。一系列具有完整测试流程的测试单元组成测试用例。\n- `TestSuite`: 测试用例合集。多个`TestCase`集合组成`TestSuite`。且`TestSuite`可以嵌套其他`TestSuite`。\n- `TestLoader`: 测试用例装载器。主要用于加载`TestCase`值`TestSuite`。通过`loadTestsFrom__()`方法加载`TestCase`，并创建其实例，然后将该实例添加至`TestSuite`中，返回`TestSuite`实例。\n- `TestRunner`: 测试用例执行器。执行器中的`run(test)`方法会自动执行`TestCase`、`TestSuite`中的`run(result)`方法，并将执行的测试结果保存至`TextTestResult`实例中，用于统计测试用例执行结果合计。\n- `TestFixture`: 测试环境构建与销毁维护。在测试用例运行初始化前使用`setUp()`准备初始环境，在测试用例执行完毕后使用`tearDown()`执行销毁，还原运行测试环境。\n\n\n参考链接\n\nhttps://blog.csdn.net/luanpeng825485697/article/details/79459771\n\n","slug":"python-lib-unittest","published":1,"updated":"2019-04-17T13:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjur15bab00002o1aopcuqx9z","content":"<p><a href=\"https://docs.python.org/3.7/library/unittest.html\" target=\"_blank\" rel=\"noopener\"><code>unittest</code></a>的入门基本应用记录。</p>\n<p>概念<br><code>unittest</code>是<code>python</code>自带的标准库之一，是<code>python</code>版的<code>junit</code>，主要用于维护执行自动化测试框架的用例。</p>\n<a id=\"more\"></a>\n<h2 id=\"核心工作原理\"><a href=\"#核心工作原理\" class=\"headerlink\" title=\"核心工作原理\"></a>核心工作原理</h2><p>核心应有有：<code>TestCase</code> <code>TestSuite</code> <code>TestLoader</code> <code>TestRunner</code> <code>TestFixture</code> 等构造函数。</p>\n<ul>\n<li><code>TestCase</code>: 测试用例。一个完整的测试单元包括 测试前准备环境的搭建(<code>setUp</code>)，执行测试代码(<code>run</code>)，以及测试后环境的还原(<code>tearDown</code>)。一系列具有完整测试流程的测试单元组成测试用例。</li>\n<li><code>TestSuite</code>: 测试用例合集。多个<code>TestCase</code>集合组成<code>TestSuite</code>。且<code>TestSuite</code>可以嵌套其他<code>TestSuite</code>。</li>\n<li><code>TestLoader</code>: 测试用例装载器。主要用于加载<code>TestCase</code>值<code>TestSuite</code>。通过<code>loadTestsFrom__()</code>方法加载<code>TestCase</code>，并创建其实例，然后将该实例添加至<code>TestSuite</code>中，返回<code>TestSuite</code>实例。</li>\n<li><code>TestRunner</code>: 测试用例执行器。执行器中的<code>run(test)</code>方法会自动执行<code>TestCase</code>、<code>TestSuite</code>中的<code>run(result)</code>方法，并将执行的测试结果保存至<code>TextTestResult</code>实例中，用于统计测试用例执行结果合计。</li>\n<li><code>TestFixture</code>: 测试环境构建与销毁维护。在测试用例运行初始化前使用<code>setUp()</code>准备初始环境，在测试用例执行完毕后使用<code>tearDown()</code>执行销毁，还原运行测试环境。</li>\n</ul>\n<p>参考链接</p>\n<p><a href=\"https://blog.csdn.net/luanpeng825485697/article/details/79459771\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/luanpeng825485697/article/details/79459771</a></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://docs.python.org/3.7/library/unittest.html\" target=\"_blank\" rel=\"noopener\"><code>unittest</code></a>的入门基本应用记录。</p>\n<p>概念<br><code>unittest</code>是<code>python</code>自带的标准库之一，是<code>python</code>版的<code>junit</code>，主要用于维护执行自动化测试框架的用例。</p>","more":"<h2 id=\"核心工作原理\"><a href=\"#核心工作原理\" class=\"headerlink\" title=\"核心工作原理\"></a>核心工作原理</h2><p>核心应有有：<code>TestCase</code> <code>TestSuite</code> <code>TestLoader</code> <code>TestRunner</code> <code>TestFixture</code> 等构造函数。</p>\n<ul>\n<li><code>TestCase</code>: 测试用例。一个完整的测试单元包括 测试前准备环境的搭建(<code>setUp</code>)，执行测试代码(<code>run</code>)，以及测试后环境的还原(<code>tearDown</code>)。一系列具有完整测试流程的测试单元组成测试用例。</li>\n<li><code>TestSuite</code>: 测试用例合集。多个<code>TestCase</code>集合组成<code>TestSuite</code>。且<code>TestSuite</code>可以嵌套其他<code>TestSuite</code>。</li>\n<li><code>TestLoader</code>: 测试用例装载器。主要用于加载<code>TestCase</code>值<code>TestSuite</code>。通过<code>loadTestsFrom__()</code>方法加载<code>TestCase</code>，并创建其实例，然后将该实例添加至<code>TestSuite</code>中，返回<code>TestSuite</code>实例。</li>\n<li><code>TestRunner</code>: 测试用例执行器。执行器中的<code>run(test)</code>方法会自动执行<code>TestCase</code>、<code>TestSuite</code>中的<code>run(result)</code>方法，并将执行的测试结果保存至<code>TextTestResult</code>实例中，用于统计测试用例执行结果合计。</li>\n<li><code>TestFixture</code>: 测试环境构建与销毁维护。在测试用例运行初始化前使用<code>setUp()</code>准备初始环境，在测试用例执行完毕后使用<code>tearDown()</code>执行销毁，还原运行测试环境。</li>\n</ul>\n<p>参考链接</p>\n<p><a href=\"https://blog.csdn.net/luanpeng825485697/article/details/79459771\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/luanpeng825485697/article/details/79459771</a></p>"},{"title":"HTTP协议学习","date":"2019-04-09T14:08:32.000Z","_content":"\n### HTTP协议\nHTTP协议是客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”全称为“Hyper Text Transfer Protocol”。\n\n<!-- more -->\n### HTTP协议历史版本\n- `HTTP 1.0`： 默认是基于短连接，即非持久连接，采用文本数据格式传输；单个tcp连接仅能维护传输单个Web对象。\n    > 无host域\n\n<br/>\n\n- `HTTP 1.1`： 默认是基于长连接，即持久连接（可配置成非持久连接），采用文本数据格式传输；单个tcp连接可以维护多个Web对象的传输。\n    > HTTP 1.1可获取host域这个参数。\n    > 长连接可有效减少TCP三次握手四次挥手的网络连接性能开销。\n    > HTTP 1.1支持只发送header信息，不带任何body信息。可以校验B/S架构模式下，Browser是否具有访问请求权限，有则返回`status: 100`，无则返回`status: 401`，从而再依返回结果将请求的body信息发送给服务器，节约网络带宽。\n    > HTTP 1.1同时也支持资源加载的断点续传。\n    > 同一时间对于同一域名，请求数量有限制，超过限制会造成网络阻塞请求。\n    \n<br/>\n\n- `HTTP 2.0`： 采用二进制数据格式传输；实现多路复用；进行头部压缩优化。[HTTP1.1与HTTP2.0区别Demo](https://http2.akamai.com/demo)\n    > ⭐️ HTTP 2.0采用*多路复用（Multiplexing）* 用以解决*线头阻塞* 的问题。核心基于Google公司开发的基于TCP的应用层协议[SPDY非标准协议](https://zh.wikipedia.org/wiki/SPDY)\n    > ⭐️ 增加\"二进制分帧层\"实现底层tcp多路复用。将多个请求在同一个TCP连接上完成，承载任意数量的双向数据流。极大的提升了传输层通信性能。\n    > HTTP 2.0采用首部压缩设计的[HPACK](http://http2.github.io/http2-spec/compression.html)算法\n    > HTTP 2.0的Server Push以及缓存策略\n    \n<br/>\n\n- `HTTP 3.0`:  核心基于UDP传输层协议的[QUIC协议](https://zhuanlan.zhihu.com/p/32553477);提供数据传输的高可靠性及0-RTT延迟；彻底解决*线头阻塞* \n    > 基于UDP传输层协议，实现高速及高可靠性的数据传输。\n    > 彻底解决http1.1遗留的线头阻塞（HOL），实现不同流的数据传输相互独立传输，互不干扰。\n    > 0-RTT，不必像TCP那样需要三次握手。\n    > 参考：\n    [QUIC协议浅析与HTTP/3.0](https://www.jianshu.com/p/bb3eeb36b479) \n    [如何看待 HTTP/3 ？](https://www.zhihu.com/question/302412059/answer/533223530)\n### HTTP/2协议\n1、二进制分帧层 (Binary Framing Layer)\n2、在单个TCP连接里多路复用请求。\n3、HTTP/2的Server Push，非常重要的一个特性。\n4、HTTP Header的压缩，采用的是HPack算法。\n5、应用层的重置连接\n6、请求优先级设置\n7、流量控制\n8、HTTP/1 的几种优化可以弃用\n参考：https://blog.wangriyu.wang/2018/05-HTTP2.html\n\n### HTTP协议在OSI模型的位置\nHTTP协议位于应用层\n<p><image src=\"https://bayuefen.oss-cn-hangzhou.aliyuncs.com/blog/20190406164742398.png?x-oss-process=style/compress_high\" width=\"600\" align=\"center\"></p>\n\n### HTTP协议的method\nGET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.\n\n```\n>>> r = requests.get('https://api.github.com/events')\n```\n\nHEAD：请求一个与GET请求的响应相同的响应，但没有响应体.\n\n```\n>>> r = requests.head('http://httpbin.org/get')\n```\n\nPOST：用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改. \n```\n>>> r = requests.post('http://httpbin.org/post', data = {'key':'value'})\n```\n\nPUT：用请求有效载荷替换目标资源的所有当前表示。\n\n```\n>>> r = requests.put('http://httpbin.org/put', data = {'key':'value'})\n```\n\nDELETE：删除指定的资源。\n\n```\n>>> r = requests.delete('http://httpbin.org/delete')\n```\n\nCONNECT：建立一个到由目标资源标识的服务器的隧道。\n\nOPTIONS：用于描述目标资源的通信选项。\n\n```\n>>> r = requests.options('http://httpbin.org/get')\n```\n\nTRACE：沿着到目标资源的路径执行一个消息环回测试。\n\nPATCH：用于对资源应用部分修改。\n\nGET和POST对比：\nGET\n1.方法用途\nGET 方法的首要目的是 获取资源\n\n2.方法特点\na) 参数可见\nGET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法\n不过也正是因此，所以 GET 方法允许被保存书签\n\nb) 数据类型只允许 ASCII\nGET 方法的数据类型只允许是 ASCII 字符，所以说传递 二进制 文件就不可以用 GET 方法了哦\n\nc) 可以保存书签\n当我们访问某一个网站的频率特别高的时候，肯定添加到书签，那其实书签就是依靠 GET 方法来保存的\n\nd) 可以被缓存\nGET 方法支持缓存，当本次请求允许被缓存时，会将资源存值本地 cache ，在未过期的情况下直接取本地 cache；缓存过期后视情况而定\n\ne) 参数会保留在浏览器历史记录\n比较直观的感受就是，我们可以在浏览器的历史记录中查看到曾经搜索过的关键字信息\n\nf) 请求长度会受限于所使用的浏览器与服务器\n不同的浏览器对于 GET 请求长度的限制也是不同的，注意这是 浏览器 / 服务器（IE、Chrome、Apache、IIS等） 对于长度的限制，而不是 HTTP 协议\n\nPOST\n1.方法用途\nPOST 方法的首要目的是 提交，POST 方法一般用于添加资源\n\n2.方法特点\na) 参数不可见，也不会被保存\n所以说 POST 方法是不可以被保存书签的\n\nb) 不能收藏为书签\n理由如上\n\nc) 不可以被缓存\n我要提交的数据被缓存在本地 cache 中想想其实也是没道理的\n\nd) 不会被保存在浏览器历史中\n同样是因为参数不可见\n\ne) 不限制请求长度\n对于 POST 方法这种以 提交 为首要目的的方法，肯定是不可以限制请求长度的\n\nf) 数据类型\n不限，所以说 POST 是可以 提交文件 到服务器的\n\ng) 请求方式\nPOST 请求与 GET 请求不同，他会首先提交 HEAD 信息，待得到 100 响应后，才会再次将 DATA 提交\n\n### HTTP协议的组成\n请求报文包含三部分：\n**·**请求行(Request line)：包含请求方法、URI、HTTP版本信息\n**·**请求首部字段(Request header)\n**·**请求内容实体\n响应报文包含三部分：（以豆瓣电影TOP250为例）\n>Request Headers\n\n> GET /top250 HTTP/1.1              \n\\#GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。\nHost: movie.douban.com\n\\#表示请求的域名是movie.douban.com\nConnection: keep-alive\n\\#表示支持长连接\nCache-Control: max-age=0\n\\#指定请求和响应遵循的缓存机制\nUpgrade-Insecure-Requests: 1\n\\#浏览器可以处理https协议\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\n\\#发出请求的用户信息\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\n\\#客户端希望接受的数据类型\nAccept-Encoding: gzip, deflate, br\n\\#浏览器发给服务器,声明浏览器支持的编码类型\nAccept-Language: zh-CN,zh;q=0.9\n\\#浏览器支持的语言分别是简体中文和中文，优先支持简体中文。\nCookie: bid=ZbyUzrJdS2w; __utmc=30149280; __utmc=223695111; __yadk_uid=nTiBvU6fTOaXD90dB6edYhp8urhJwCjc; viewed=\"27599884\"; gr_user_id=4aa3ad30-748f-488c-b5b3-bcff3f0456d4; douban-fav-remind=1; ll=\"118172\"; _vwo_uuid_v2=DE51C937E99B505F3A54AE46B8619B83A|80d039133d473653fabc07636080bbb8; push_noty_num=0; push_doumail_num=0; __utmv=30149280.19454; ap_v=0,6.0; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1554617137%2C%22https%3A%2F%2Fwww.\nbaidu.com%2Flink%3Furl%3Dt8BO_5f8zl_78xcE_dnmyhd_1xbKVsXtXZv_yHxp72UVO88nbOSLQSA1xMPpsfX2%26wd%3\nD%26eqid%3Da8c4f714000c0677000000035ca9932e%22%5D;\n _pk_id.100001.4cf6=e94317b751ae8229.1554384156.13.1554617137.1554583408.; _pk_ses.100001.4cf6=*; __utma=30149280.106710662.1554384144.1554583409.1554617137.12; __utmb=30149280.0.10.1554617137; __utmz=30149280.1554617137.12.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; __utma=223695111.1166551075.1554384156.1554583409.1554617137.13; __utmb=223695111.0.10.1554617137; __utmz=223695111.1554617137.13.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic\n\\#http是无状态的，所以引入了cookie来管理服务器与客户端之间的状态\n\n响应报文包含三部分：\n**·**状态行：包含HTTP版本、状态码、状态码的原因短语\n**·**响应首部字段\n**·**响应内容实体\n> Response header\n\n> HTTP/1.1 200 OK\n\\#响应状态\nDate: Sun, 07 Apr 2019 06:05:45 GMT\n\\#生成消息的具体时间和日期\nContent-Type: text/html; charset=utf-8\n\\#服务器发送 html 文档，字符集为 UTF-8\nTransfer-Encoding: chunked\nConnection: keep-alive\nKeep-Alive: timeout=30\nVary: Accept-Encoding\n\\#服务器响应时根据请求头中的的值返回不同的内容\nX-Xss-Protection: 1; mode=block\n设置浏览器的XSS防护机制，浏览器如果检测到恶意代码，则不渲染恶意代码\nX-Douban-Mobileapp: 0\nExpires: Sun, 1 Jan 2006 01:00:00 GMT\n浏览器会在指定过期时间内使用本地缓存\nPragma: no-cache\nCache-Control: must-revalidate, no-cache, private\nX-DAE-Node: brand4\nX-DAE-App: movie\nServer: dae\nX-Content-Type-Options: nosniff\nContent-Encoding: gzip\n文档使用的 MIME 类型是 text/html，并且对内容进行了 gzip 压缩\n\n### HTTP协议的状态码\n1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。\n2xx （成功） 表示成功处理了请求的状态代码。\n3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\n4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。\n5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。\n常见的：200 – 服务器成功返回网页 |404 – 请求的网页不存在 |503 – 服务不可用 \n\n状态码                     |中文描述 \n:--------------------:|:--------------------:\n100|（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  \n101|（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。\n102|（已接受）已经接受请求，但未处理完成\n200| （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n201|（已创建）  请求成功并且服务器创建了新的资源。\n202|（已接受）  服务器已接受请求，但尚未处理。\n203|（非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204|（无内容）  服务器成功处理了请求，但没有返回任何内容。\n205|（重置内容） 服务器成功处理了请求，但没有返回任何内容。 \n206|（部分内容）  服务器成功处理了部分 GET 请求。\n300|（多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 \n301|（永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n302|（临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n303|（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。\n304|（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 \n305|（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。\n307|（临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n400|（错误请求） 服务器不理解请求的语法。\n401|未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 \n403|（禁止） 服务器拒绝请求。 \n404|（未找到） 服务器找不到请求的网页。 \n405|（方法禁用） 禁用请求中指定的方法。\n406|（不接受） 无法使用请求的内容特性响应请求的网页。 \n407|（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。\n408|（请求超时）  服务器等候请求时发生超时。 \n409|（冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 \n410|（已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 \n411|（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 \n412|（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 \n413|（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 \n414|（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 \n415|（不支持的媒体类型） 请求的格式不受请求页面的支持。 \n416|（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 \n417|（未满足期望值） 服务器未满足”期望”请求标头字段的要求。\n500|（服务器内部错误）  服务器遇到错误，无法完成请求。 \n501|（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。\n502|（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\n503|（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 \n504|（网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 \n505|（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\n  \n  \n### cookies和会话\n因为HTTP是无状态的，对事物处理没有记忆能力。cookies和会话出现用于保持HTTP连接状态，\n会话在服务端，用来保存用户的会话信息；cookies在客户端，浏览器下次访问网页时会自动附带上它发送给服务器，\n服务器通过识别cookies找到对应的会话判断用户状态。\nPS:关闭浏览器不会导致会话被删除，反而没有存储到硬盘上的cookie会消失，因此为了节省存储空间需要为会话设置一个失效时间。\n","source":"_posts/http-learn-notes.md","raw":"---\ntitle: HTTP协议学习\ndate: 2019-04-09 22:08:32\ntags:\n    - HTTP\n    - 日记\n    - 学习Vlog\n---\n\n### HTTP协议\nHTTP协议是客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”全称为“Hyper Text Transfer Protocol”。\n\n<!-- more -->\n### HTTP协议历史版本\n- `HTTP 1.0`： 默认是基于短连接，即非持久连接，采用文本数据格式传输；单个tcp连接仅能维护传输单个Web对象。\n    > 无host域\n\n<br/>\n\n- `HTTP 1.1`： 默认是基于长连接，即持久连接（可配置成非持久连接），采用文本数据格式传输；单个tcp连接可以维护多个Web对象的传输。\n    > HTTP 1.1可获取host域这个参数。\n    > 长连接可有效减少TCP三次握手四次挥手的网络连接性能开销。\n    > HTTP 1.1支持只发送header信息，不带任何body信息。可以校验B/S架构模式下，Browser是否具有访问请求权限，有则返回`status: 100`，无则返回`status: 401`，从而再依返回结果将请求的body信息发送给服务器，节约网络带宽。\n    > HTTP 1.1同时也支持资源加载的断点续传。\n    > 同一时间对于同一域名，请求数量有限制，超过限制会造成网络阻塞请求。\n    \n<br/>\n\n- `HTTP 2.0`： 采用二进制数据格式传输；实现多路复用；进行头部压缩优化。[HTTP1.1与HTTP2.0区别Demo](https://http2.akamai.com/demo)\n    > ⭐️ HTTP 2.0采用*多路复用（Multiplexing）* 用以解决*线头阻塞* 的问题。核心基于Google公司开发的基于TCP的应用层协议[SPDY非标准协议](https://zh.wikipedia.org/wiki/SPDY)\n    > ⭐️ 增加\"二进制分帧层\"实现底层tcp多路复用。将多个请求在同一个TCP连接上完成，承载任意数量的双向数据流。极大的提升了传输层通信性能。\n    > HTTP 2.0采用首部压缩设计的[HPACK](http://http2.github.io/http2-spec/compression.html)算法\n    > HTTP 2.0的Server Push以及缓存策略\n    \n<br/>\n\n- `HTTP 3.0`:  核心基于UDP传输层协议的[QUIC协议](https://zhuanlan.zhihu.com/p/32553477);提供数据传输的高可靠性及0-RTT延迟；彻底解决*线头阻塞* \n    > 基于UDP传输层协议，实现高速及高可靠性的数据传输。\n    > 彻底解决http1.1遗留的线头阻塞（HOL），实现不同流的数据传输相互独立传输，互不干扰。\n    > 0-RTT，不必像TCP那样需要三次握手。\n    > 参考：\n    [QUIC协议浅析与HTTP/3.0](https://www.jianshu.com/p/bb3eeb36b479) \n    [如何看待 HTTP/3 ？](https://www.zhihu.com/question/302412059/answer/533223530)\n### HTTP/2协议\n1、二进制分帧层 (Binary Framing Layer)\n2、在单个TCP连接里多路复用请求。\n3、HTTP/2的Server Push，非常重要的一个特性。\n4、HTTP Header的压缩，采用的是HPack算法。\n5、应用层的重置连接\n6、请求优先级设置\n7、流量控制\n8、HTTP/1 的几种优化可以弃用\n参考：https://blog.wangriyu.wang/2018/05-HTTP2.html\n\n### HTTP协议在OSI模型的位置\nHTTP协议位于应用层\n<p><image src=\"https://bayuefen.oss-cn-hangzhou.aliyuncs.com/blog/20190406164742398.png?x-oss-process=style/compress_high\" width=\"600\" align=\"center\"></p>\n\n### HTTP协议的method\nGET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.\n\n```\n>>> r = requests.get('https://api.github.com/events')\n```\n\nHEAD：请求一个与GET请求的响应相同的响应，但没有响应体.\n\n```\n>>> r = requests.head('http://httpbin.org/get')\n```\n\nPOST：用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改. \n```\n>>> r = requests.post('http://httpbin.org/post', data = {'key':'value'})\n```\n\nPUT：用请求有效载荷替换目标资源的所有当前表示。\n\n```\n>>> r = requests.put('http://httpbin.org/put', data = {'key':'value'})\n```\n\nDELETE：删除指定的资源。\n\n```\n>>> r = requests.delete('http://httpbin.org/delete')\n```\n\nCONNECT：建立一个到由目标资源标识的服务器的隧道。\n\nOPTIONS：用于描述目标资源的通信选项。\n\n```\n>>> r = requests.options('http://httpbin.org/get')\n```\n\nTRACE：沿着到目标资源的路径执行一个消息环回测试。\n\nPATCH：用于对资源应用部分修改。\n\nGET和POST对比：\nGET\n1.方法用途\nGET 方法的首要目的是 获取资源\n\n2.方法特点\na) 参数可见\nGET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法\n不过也正是因此，所以 GET 方法允许被保存书签\n\nb) 数据类型只允许 ASCII\nGET 方法的数据类型只允许是 ASCII 字符，所以说传递 二进制 文件就不可以用 GET 方法了哦\n\nc) 可以保存书签\n当我们访问某一个网站的频率特别高的时候，肯定添加到书签，那其实书签就是依靠 GET 方法来保存的\n\nd) 可以被缓存\nGET 方法支持缓存，当本次请求允许被缓存时，会将资源存值本地 cache ，在未过期的情况下直接取本地 cache；缓存过期后视情况而定\n\ne) 参数会保留在浏览器历史记录\n比较直观的感受就是，我们可以在浏览器的历史记录中查看到曾经搜索过的关键字信息\n\nf) 请求长度会受限于所使用的浏览器与服务器\n不同的浏览器对于 GET 请求长度的限制也是不同的，注意这是 浏览器 / 服务器（IE、Chrome、Apache、IIS等） 对于长度的限制，而不是 HTTP 协议\n\nPOST\n1.方法用途\nPOST 方法的首要目的是 提交，POST 方法一般用于添加资源\n\n2.方法特点\na) 参数不可见，也不会被保存\n所以说 POST 方法是不可以被保存书签的\n\nb) 不能收藏为书签\n理由如上\n\nc) 不可以被缓存\n我要提交的数据被缓存在本地 cache 中想想其实也是没道理的\n\nd) 不会被保存在浏览器历史中\n同样是因为参数不可见\n\ne) 不限制请求长度\n对于 POST 方法这种以 提交 为首要目的的方法，肯定是不可以限制请求长度的\n\nf) 数据类型\n不限，所以说 POST 是可以 提交文件 到服务器的\n\ng) 请求方式\nPOST 请求与 GET 请求不同，他会首先提交 HEAD 信息，待得到 100 响应后，才会再次将 DATA 提交\n\n### HTTP协议的组成\n请求报文包含三部分：\n**·**请求行(Request line)：包含请求方法、URI、HTTP版本信息\n**·**请求首部字段(Request header)\n**·**请求内容实体\n响应报文包含三部分：（以豆瓣电影TOP250为例）\n>Request Headers\n\n> GET /top250 HTTP/1.1              \n\\#GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。\nHost: movie.douban.com\n\\#表示请求的域名是movie.douban.com\nConnection: keep-alive\n\\#表示支持长连接\nCache-Control: max-age=0\n\\#指定请求和响应遵循的缓存机制\nUpgrade-Insecure-Requests: 1\n\\#浏览器可以处理https协议\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\n\\#发出请求的用户信息\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\n\\#客户端希望接受的数据类型\nAccept-Encoding: gzip, deflate, br\n\\#浏览器发给服务器,声明浏览器支持的编码类型\nAccept-Language: zh-CN,zh;q=0.9\n\\#浏览器支持的语言分别是简体中文和中文，优先支持简体中文。\nCookie: bid=ZbyUzrJdS2w; __utmc=30149280; __utmc=223695111; __yadk_uid=nTiBvU6fTOaXD90dB6edYhp8urhJwCjc; viewed=\"27599884\"; gr_user_id=4aa3ad30-748f-488c-b5b3-bcff3f0456d4; douban-fav-remind=1; ll=\"118172\"; _vwo_uuid_v2=DE51C937E99B505F3A54AE46B8619B83A|80d039133d473653fabc07636080bbb8; push_noty_num=0; push_doumail_num=0; __utmv=30149280.19454; ap_v=0,6.0; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1554617137%2C%22https%3A%2F%2Fwww.\nbaidu.com%2Flink%3Furl%3Dt8BO_5f8zl_78xcE_dnmyhd_1xbKVsXtXZv_yHxp72UVO88nbOSLQSA1xMPpsfX2%26wd%3\nD%26eqid%3Da8c4f714000c0677000000035ca9932e%22%5D;\n _pk_id.100001.4cf6=e94317b751ae8229.1554384156.13.1554617137.1554583408.; _pk_ses.100001.4cf6=*; __utma=30149280.106710662.1554384144.1554583409.1554617137.12; __utmb=30149280.0.10.1554617137; __utmz=30149280.1554617137.12.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; __utma=223695111.1166551075.1554384156.1554583409.1554617137.13; __utmb=223695111.0.10.1554617137; __utmz=223695111.1554617137.13.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic\n\\#http是无状态的，所以引入了cookie来管理服务器与客户端之间的状态\n\n响应报文包含三部分：\n**·**状态行：包含HTTP版本、状态码、状态码的原因短语\n**·**响应首部字段\n**·**响应内容实体\n> Response header\n\n> HTTP/1.1 200 OK\n\\#响应状态\nDate: Sun, 07 Apr 2019 06:05:45 GMT\n\\#生成消息的具体时间和日期\nContent-Type: text/html; charset=utf-8\n\\#服务器发送 html 文档，字符集为 UTF-8\nTransfer-Encoding: chunked\nConnection: keep-alive\nKeep-Alive: timeout=30\nVary: Accept-Encoding\n\\#服务器响应时根据请求头中的的值返回不同的内容\nX-Xss-Protection: 1; mode=block\n设置浏览器的XSS防护机制，浏览器如果检测到恶意代码，则不渲染恶意代码\nX-Douban-Mobileapp: 0\nExpires: Sun, 1 Jan 2006 01:00:00 GMT\n浏览器会在指定过期时间内使用本地缓存\nPragma: no-cache\nCache-Control: must-revalidate, no-cache, private\nX-DAE-Node: brand4\nX-DAE-App: movie\nServer: dae\nX-Content-Type-Options: nosniff\nContent-Encoding: gzip\n文档使用的 MIME 类型是 text/html，并且对内容进行了 gzip 压缩\n\n### HTTP协议的状态码\n1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。\n2xx （成功） 表示成功处理了请求的状态代码。\n3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\n4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。\n5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。\n常见的：200 – 服务器成功返回网页 |404 – 请求的网页不存在 |503 – 服务不可用 \n\n状态码                     |中文描述 \n:--------------------:|:--------------------:\n100|（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  \n101|（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。\n102|（已接受）已经接受请求，但未处理完成\n200| （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n201|（已创建）  请求成功并且服务器创建了新的资源。\n202|（已接受）  服务器已接受请求，但尚未处理。\n203|（非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204|（无内容）  服务器成功处理了请求，但没有返回任何内容。\n205|（重置内容） 服务器成功处理了请求，但没有返回任何内容。 \n206|（部分内容）  服务器成功处理了部分 GET 请求。\n300|（多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 \n301|（永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n302|（临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n303|（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。\n304|（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 \n305|（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。\n307|（临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n400|（错误请求） 服务器不理解请求的语法。\n401|未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 \n403|（禁止） 服务器拒绝请求。 \n404|（未找到） 服务器找不到请求的网页。 \n405|（方法禁用） 禁用请求中指定的方法。\n406|（不接受） 无法使用请求的内容特性响应请求的网页。 \n407|（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。\n408|（请求超时）  服务器等候请求时发生超时。 \n409|（冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 \n410|（已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 \n411|（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 \n412|（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 \n413|（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 \n414|（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 \n415|（不支持的媒体类型） 请求的格式不受请求页面的支持。 \n416|（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 \n417|（未满足期望值） 服务器未满足”期望”请求标头字段的要求。\n500|（服务器内部错误）  服务器遇到错误，无法完成请求。 \n501|（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。\n502|（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\n503|（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 \n504|（网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 \n505|（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\n  \n  \n### cookies和会话\n因为HTTP是无状态的，对事物处理没有记忆能力。cookies和会话出现用于保持HTTP连接状态，\n会话在服务端，用来保存用户的会话信息；cookies在客户端，浏览器下次访问网页时会自动附带上它发送给服务器，\n服务器通过识别cookies找到对应的会话判断用户状态。\nPS:关闭浏览器不会导致会话被删除，反而没有存储到硬盘上的cookie会消失，因此为了节省存储空间需要为会话设置一个失效时间。\n","slug":"http-learn-notes","published":1,"updated":"2019-04-18T03:35:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjur15bah00012o1aq9x2se85","content":"<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>HTTP协议是客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”全称为“Hyper Text Transfer Protocol”。</p>\n<a id=\"more\"></a>\n<h3 id=\"HTTP协议历史版本\"><a href=\"#HTTP协议历史版本\" class=\"headerlink\" title=\"HTTP协议历史版本\"></a>HTTP协议历史版本</h3><ul>\n<li><code>HTTP 1.0</code>： 默认是基于短连接，即非持久连接，采用文本数据格式传输；单个tcp连接仅能维护传输单个Web对象。<blockquote>\n<p>无host域</p>\n</blockquote>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li><code>HTTP 1.1</code>： 默认是基于长连接，即持久连接（可配置成非持久连接），采用文本数据格式传输；单个tcp连接可以维护多个Web对象的传输。<blockquote>\n<p>HTTP 1.1可获取host域这个参数。<br>长连接可有效减少TCP三次握手四次挥手的网络连接性能开销。<br>HTTP 1.1支持只发送header信息，不带任何body信息。可以校验B/S架构模式下，Browser是否具有访问请求权限，有则返回<code>status: 100</code>，无则返回<code>status: 401</code>，从而再依返回结果将请求的body信息发送给服务器，节约网络带宽。<br>HTTP 1.1同时也支持资源加载的断点续传。<br>同一时间对于同一域名，请求数量有限制，超过限制会造成网络阻塞请求。</p>\n</blockquote>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li><code>HTTP 2.0</code>： 采用二进制数据格式传输；实现多路复用；进行头部压缩优化。<a href=\"https://http2.akamai.com/demo\" target=\"_blank\" rel=\"noopener\">HTTP1.1与HTTP2.0区别Demo</a><blockquote>\n<p>⭐️ HTTP 2.0采用<em>多路复用（Multiplexing）</em> 用以解决<em>线头阻塞</em> 的问题。核心基于Google公司开发的基于TCP的应用层协议<a href=\"https://zh.wikipedia.org/wiki/SPDY\" target=\"_blank\" rel=\"noopener\">SPDY非标准协议</a><br>⭐️ 增加”二进制分帧层”实现底层tcp多路复用。将多个请求在同一个TCP连接上完成，承载任意数量的双向数据流。极大的提升了传输层通信性能。<br>HTTP 2.0采用首部压缩设计的<a href=\"http://http2.github.io/http2-spec/compression.html\" target=\"_blank\" rel=\"noopener\">HPACK</a>算法<br>HTTP 2.0的Server Push以及缓存策略</p>\n</blockquote>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li><code>HTTP 3.0</code>:  核心基于UDP传输层协议的<a href=\"https://zhuanlan.zhihu.com/p/32553477\" target=\"_blank\" rel=\"noopener\">QUIC协议</a>;提供数据传输的高可靠性及0-RTT延迟；彻底解决<em>线头阻塞</em> <blockquote>\n<p>基于UDP传输层协议，实现高速及高可靠性的数据传输。<br>彻底解决http1.1遗留的线头阻塞（HOL），实现不同流的数据传输相互独立传输，互不干扰。<br>0-RTT，不必像TCP那样需要三次握手。<br>参考：<br>  <a href=\"https://www.jianshu.com/p/bb3eeb36b479\" target=\"_blank\" rel=\"noopener\">QUIC协议浅析与HTTP/3.0</a><br>  <a href=\"https://www.zhihu.com/question/302412059/answer/533223530\" target=\"_blank\" rel=\"noopener\">如何看待 HTTP/3 ？</a></p>\n</blockquote>\n<h3 id=\"HTTP-2协议\"><a href=\"#HTTP-2协议\" class=\"headerlink\" title=\"HTTP/2协议\"></a>HTTP/2协议</h3>1、二进制分帧层 (Binary Framing Layer)<br>2、在单个TCP连接里多路复用请求。<br>3、HTTP/2的Server Push，非常重要的一个特性。<br>4、HTTP Header的压缩，采用的是HPack算法。<br>5、应用层的重置连接<br>6、请求优先级设置<br>7、流量控制<br>8、HTTP/1 的几种优化可以弃用<br>参考：<a href=\"https://blog.wangriyu.wang/2018/05-HTTP2.html\" target=\"_blank\" rel=\"noopener\">https://blog.wangriyu.wang/2018/05-HTTP2.html</a></li>\n</ul>\n<h3 id=\"HTTP协议在OSI模型的位置\"><a href=\"#HTTP协议在OSI模型的位置\" class=\"headerlink\" title=\"HTTP协议在OSI模型的位置\"></a>HTTP协议在OSI模型的位置</h3><p>HTTP协议位于应用层</p>\n<p><image src=\"https://bayuefen.oss-cn-hangzhou.aliyuncs.com/blog/20190406164742398.png?x-oss-process=style/compress_high\" width=\"600\" align=\"center\"></image></p>\n\n<h3 id=\"HTTP协议的method\"><a href=\"#HTTP协议的method\" class=\"headerlink\" title=\"HTTP协议的method\"></a>HTTP协议的method</h3><p>GET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.get(<span class=\"string\">'https://api.github.com/events'</span>)</span><br></pre></td></tr></table></figure>\n<p>HEAD：请求一个与GET请求的响应相同的响应，但没有响应体.</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.head(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure>\n<p>POST：用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改.<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.post(<span class=\"string\">'http://httpbin.org/post'</span>, data = &#123;<span class=\"string\">'key'</span><span class=\"symbol\">:<span class=\"string\">'value'</span></span>&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>PUT：用请求有效载荷替换目标资源的所有当前表示。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.put(<span class=\"string\">'http://httpbin.org/put'</span>, data = &#123;<span class=\"string\">'key'</span><span class=\"symbol\">:<span class=\"string\">'value'</span></span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>DELETE：删除指定的资源。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.delete(<span class=\"string\">'http://httpbin.org/delete'</span>)</span><br></pre></td></tr></table></figure>\n<p>CONNECT：建立一个到由目标资源标识的服务器的隧道。</p>\n<p>OPTIONS：用于描述目标资源的通信选项。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.options(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure>\n<p>TRACE：沿着到目标资源的路径执行一个消息环回测试。</p>\n<p>PATCH：用于对资源应用部分修改。</p>\n<p>GET和POST对比：<br>GET<br>1.方法用途<br>GET 方法的首要目的是 获取资源</p>\n<p>2.方法特点<br>a) 参数可见<br>GET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法<br>不过也正是因此，所以 GET 方法允许被保存书签</p>\n<p>b) 数据类型只允许 ASCII<br>GET 方法的数据类型只允许是 ASCII 字符，所以说传递 二进制 文件就不可以用 GET 方法了哦</p>\n<p>c) 可以保存书签<br>当我们访问某一个网站的频率特别高的时候，肯定添加到书签，那其实书签就是依靠 GET 方法来保存的</p>\n<p>d) 可以被缓存<br>GET 方法支持缓存，当本次请求允许被缓存时，会将资源存值本地 cache ，在未过期的情况下直接取本地 cache；缓存过期后视情况而定</p>\n<p>e) 参数会保留在浏览器历史记录<br>比较直观的感受就是，我们可以在浏览器的历史记录中查看到曾经搜索过的关键字信息</p>\n<p>f) 请求长度会受限于所使用的浏览器与服务器<br>不同的浏览器对于 GET 请求长度的限制也是不同的，注意这是 浏览器 / 服务器（IE、Chrome、Apache、IIS等） 对于长度的限制，而不是 HTTP 协议</p>\n<p>POST<br>1.方法用途<br>POST 方法的首要目的是 提交，POST 方法一般用于添加资源</p>\n<p>2.方法特点<br>a) 参数不可见，也不会被保存<br>所以说 POST 方法是不可以被保存书签的</p>\n<p>b) 不能收藏为书签<br>理由如上</p>\n<p>c) 不可以被缓存<br>我要提交的数据被缓存在本地 cache 中想想其实也是没道理的</p>\n<p>d) 不会被保存在浏览器历史中<br>同样是因为参数不可见</p>\n<p>e) 不限制请求长度<br>对于 POST 方法这种以 提交 为首要目的的方法，肯定是不可以限制请求长度的</p>\n<p>f) 数据类型<br>不限，所以说 POST 是可以 提交文件 到服务器的</p>\n<p>g) 请求方式<br>POST 请求与 GET 请求不同，他会首先提交 HEAD 信息，待得到 100 响应后，才会再次将 DATA 提交</p>\n<h3 id=\"HTTP协议的组成\"><a href=\"#HTTP协议的组成\" class=\"headerlink\" title=\"HTTP协议的组成\"></a>HTTP协议的组成</h3><p>请求报文包含三部分：<br><strong>·</strong>请求行(Request line)：包含请求方法、URI、HTTP版本信息<br><strong>·</strong>请求首部字段(Request header)<br><strong>·</strong>请求内容实体<br>响应报文包含三部分：（以豆瓣电影TOP250为例）</p>\n<blockquote>\n<p>Request Headers</p>\n</blockquote>\n<blockquote>\n<p>GET /top250 HTTP/1.1<br>#GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。<br>Host: movie.douban.com<br>#表示请求的域名是movie.douban.com<br>Connection: keep-alive<br>#表示支持长连接<br>Cache-Control: max-age=0<br>#指定请求和响应遵循的缓存机制<br>Upgrade-Insecure-Requests: 1<br>#浏览器可以处理https协议<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36<br>#发出请求的用户信息<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3<br>#客户端希望接受的数据类型<br>Accept-Encoding: gzip, deflate, br<br>#浏览器发给服务器,声明浏览器支持的编码类型<br>Accept-Language: zh-CN,zh;q=0.9<br>#浏览器支持的语言分别是简体中文和中文，优先支持简体中文。<br>Cookie: bid=ZbyUzrJdS2w; <strong>utmc=30149280; </strong>utmc=223695111; <strong>yadk_uid=nTiBvU6fTOaXD90dB6edYhp8urhJwCjc; viewed=”27599884”; gr_user_id=4aa3ad30-748f-488c-b5b3-bcff3f0456d4; douban-fav-remind=1; ll=”118172”; _vwo_uuid_v2=DE51C937E99B505F3A54AE46B8619B83A|80d039133d473653fabc07636080bbb8; push_noty_num=0; push_doumail_num=0; </strong>utmv=30149280.19454; ap_v=0,6.0; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1554617137%2C%22https%3A%2F%2Fwww.<br>baidu.com%2Flink%3Furl%3Dt8BO_5f8zl_78xcE_dnmyhd_1xbKVsXtXZv_yHxp72UVO88nbOSLQSA1xMPpsfX2%26wd%3<br>D%26eqid%3Da8c4f714000c0677000000035ca9932e%22%5D;<br> _pk_id.100001.4cf6=e94317b751ae8229.1554384156.13.1554617137.1554583408.; _pk_ses.100001.4cf6=*; <strong>utma=30149280.106710662.1554384144.1554583409.1554617137.12; </strong>utmb=30149280.0.10.1554617137; <strong>utmz=30149280.1554617137.12.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; </strong>utma=223695111.1166551075.1554384156.1554583409.1554617137.13; <strong>utmb=223695111.0.10.1554617137; </strong>utmz=223695111.1554617137.13.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic<br>#http是无状态的，所以引入了cookie来管理服务器与客户端之间的状态</p>\n</blockquote>\n<p>响应报文包含三部分：<br><strong>·</strong>状态行：包含HTTP版本、状态码、状态码的原因短语<br><strong>·</strong>响应首部字段<br><strong>·</strong>响应内容实体</p>\n<blockquote>\n<p>Response header</p>\n</blockquote>\n<blockquote>\n<p>HTTP/1.1 200 OK<br>#响应状态<br>Date: Sun, 07 Apr 2019 06:05:45 GMT<br>#生成消息的具体时间和日期<br>Content-Type: text/html; charset=utf-8<br>#服务器发送 html 文档，字符集为 UTF-8<br>Transfer-Encoding: chunked<br>Connection: keep-alive<br>Keep-Alive: timeout=30<br>Vary: Accept-Encoding<br>#服务器响应时根据请求头中的的值返回不同的内容<br>X-Xss-Protection: 1; mode=block<br>设置浏览器的XSS防护机制，浏览器如果检测到恶意代码，则不渲染恶意代码<br>X-Douban-Mobileapp: 0<br>Expires: Sun, 1 Jan 2006 01:00:00 GMT<br>浏览器会在指定过期时间内使用本地缓存<br>Pragma: no-cache<br>Cache-Control: must-revalidate, no-cache, private<br>X-DAE-Node: brand4<br>X-DAE-App: movie<br>Server: dae<br>X-Content-Type-Options: nosniff<br>Content-Encoding: gzip<br>文档使用的 MIME 类型是 text/html，并且对内容进行了 gzip 压缩</p>\n</blockquote>\n<h3 id=\"HTTP协议的状态码\"><a href=\"#HTTP协议的状态码\" class=\"headerlink\" title=\"HTTP协议的状态码\"></a>HTTP协议的状态码</h3><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。<br>2xx （成功） 表示成功处理了请求的状态代码。<br>3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。<br>4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。<br>5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。<br>常见的：200 – 服务器成功返回网页 |404 – 请求的网页不存在 |503 – 服务不可用 </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">状态码</th>\n<th style=\"text-align:center\">中文描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">101</td>\n<td style=\"text-align:center\">（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">102</td>\n<td style=\"text-align:center\">（已接受）已经接受请求，但未处理完成</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">200</td>\n<td style=\"text-align:center\">（成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">201</td>\n<td style=\"text-align:center\">（已创建）  请求成功并且服务器创建了新的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">202</td>\n<td style=\"text-align:center\">（已接受）  服务器已接受请求，但尚未处理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">203</td>\n<td style=\"text-align:center\">（非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">204</td>\n<td style=\"text-align:center\">（无内容）  服务器成功处理了请求，但没有返回任何内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">205</td>\n<td style=\"text-align:center\">（重置内容） 服务器成功处理了请求，但没有返回任何内容。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">206</td>\n<td style=\"text-align:center\">（部分内容）  服务器成功处理了部分 GET 请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">300</td>\n<td style=\"text-align:center\">（多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">301</td>\n<td style=\"text-align:center\">（永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">302</td>\n<td style=\"text-align:center\">（临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">303</td>\n<td style=\"text-align:center\">（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">304</td>\n<td style=\"text-align:center\">（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">305</td>\n<td style=\"text-align:center\">（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">307</td>\n<td style=\"text-align:center\">（临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">400</td>\n<td style=\"text-align:center\">（错误请求） 服务器不理解请求的语法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">401</td>\n<td style=\"text-align:center\">未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">403</td>\n<td style=\"text-align:center\">（禁止） 服务器拒绝请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">404</td>\n<td style=\"text-align:center\">（未找到） 服务器找不到请求的网页。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">405</td>\n<td style=\"text-align:center\">（方法禁用） 禁用请求中指定的方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">406</td>\n<td style=\"text-align:center\">（不接受） 无法使用请求的内容特性响应请求的网页。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">407</td>\n<td style=\"text-align:center\">（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">408</td>\n<td style=\"text-align:center\">（请求超时）  服务器等候请求时发生超时。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">409</td>\n<td style=\"text-align:center\">（冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">410</td>\n<td style=\"text-align:center\">（已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">411</td>\n<td style=\"text-align:center\">（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">412</td>\n<td style=\"text-align:center\">（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">413</td>\n<td style=\"text-align:center\">（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">414</td>\n<td style=\"text-align:center\">（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">415</td>\n<td style=\"text-align:center\">（不支持的媒体类型） 请求的格式不受请求页面的支持。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">416</td>\n<td style=\"text-align:center\">（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">417</td>\n<td style=\"text-align:center\">（未满足期望值） 服务器未满足”期望”请求标头字段的要求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">（服务器内部错误）  服务器遇到错误，无法完成请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">501</td>\n<td style=\"text-align:center\">（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">502</td>\n<td style=\"text-align:center\">（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">503</td>\n<td style=\"text-align:center\">（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">504</td>\n<td style=\"text-align:center\">（网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">505</td>\n<td style=\"text-align:center\">（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"cookies和会话\"><a href=\"#cookies和会话\" class=\"headerlink\" title=\"cookies和会话\"></a>cookies和会话</h3><p>因为HTTP是无状态的，对事物处理没有记忆能力。cookies和会话出现用于保持HTTP连接状态，<br>会话在服务端，用来保存用户的会话信息；cookies在客户端，浏览器下次访问网页时会自动附带上它发送给服务器，<br>服务器通过识别cookies找到对应的会话判断用户状态。<br>PS:关闭浏览器不会导致会话被删除，反而没有存储到硬盘上的cookie会消失，因此为了节省存储空间需要为会话设置一个失效时间。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>HTTP协议是客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”全称为“Hyper Text Transfer Protocol”。</p>","more":"<h3 id=\"HTTP协议历史版本\"><a href=\"#HTTP协议历史版本\" class=\"headerlink\" title=\"HTTP协议历史版本\"></a>HTTP协议历史版本</h3><ul>\n<li><code>HTTP 1.0</code>： 默认是基于短连接，即非持久连接，采用文本数据格式传输；单个tcp连接仅能维护传输单个Web对象。<blockquote>\n<p>无host域</p>\n</blockquote>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li><code>HTTP 1.1</code>： 默认是基于长连接，即持久连接（可配置成非持久连接），采用文本数据格式传输；单个tcp连接可以维护多个Web对象的传输。<blockquote>\n<p>HTTP 1.1可获取host域这个参数。<br>长连接可有效减少TCP三次握手四次挥手的网络连接性能开销。<br>HTTP 1.1支持只发送header信息，不带任何body信息。可以校验B/S架构模式下，Browser是否具有访问请求权限，有则返回<code>status: 100</code>，无则返回<code>status: 401</code>，从而再依返回结果将请求的body信息发送给服务器，节约网络带宽。<br>HTTP 1.1同时也支持资源加载的断点续传。<br>同一时间对于同一域名，请求数量有限制，超过限制会造成网络阻塞请求。</p>\n</blockquote>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li><code>HTTP 2.0</code>： 采用二进制数据格式传输；实现多路复用；进行头部压缩优化。<a href=\"https://http2.akamai.com/demo\" target=\"_blank\" rel=\"noopener\">HTTP1.1与HTTP2.0区别Demo</a><blockquote>\n<p>⭐️ HTTP 2.0采用<em>多路复用（Multiplexing）</em> 用以解决<em>线头阻塞</em> 的问题。核心基于Google公司开发的基于TCP的应用层协议<a href=\"https://zh.wikipedia.org/wiki/SPDY\" target=\"_blank\" rel=\"noopener\">SPDY非标准协议</a><br>⭐️ 增加”二进制分帧层”实现底层tcp多路复用。将多个请求在同一个TCP连接上完成，承载任意数量的双向数据流。极大的提升了传输层通信性能。<br>HTTP 2.0采用首部压缩设计的<a href=\"http://http2.github.io/http2-spec/compression.html\" target=\"_blank\" rel=\"noopener\">HPACK</a>算法<br>HTTP 2.0的Server Push以及缓存策略</p>\n</blockquote>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li><code>HTTP 3.0</code>:  核心基于UDP传输层协议的<a href=\"https://zhuanlan.zhihu.com/p/32553477\" target=\"_blank\" rel=\"noopener\">QUIC协议</a>;提供数据传输的高可靠性及0-RTT延迟；彻底解决<em>线头阻塞</em> <blockquote>\n<p>基于UDP传输层协议，实现高速及高可靠性的数据传输。<br>彻底解决http1.1遗留的线头阻塞（HOL），实现不同流的数据传输相互独立传输，互不干扰。<br>0-RTT，不必像TCP那样需要三次握手。<br>参考：<br>  <a href=\"https://www.jianshu.com/p/bb3eeb36b479\" target=\"_blank\" rel=\"noopener\">QUIC协议浅析与HTTP/3.0</a><br>  <a href=\"https://www.zhihu.com/question/302412059/answer/533223530\" target=\"_blank\" rel=\"noopener\">如何看待 HTTP/3 ？</a></p>\n</blockquote>\n<h3 id=\"HTTP-2协议\"><a href=\"#HTTP-2协议\" class=\"headerlink\" title=\"HTTP/2协议\"></a>HTTP/2协议</h3>1、二进制分帧层 (Binary Framing Layer)<br>2、在单个TCP连接里多路复用请求。<br>3、HTTP/2的Server Push，非常重要的一个特性。<br>4、HTTP Header的压缩，采用的是HPack算法。<br>5、应用层的重置连接<br>6、请求优先级设置<br>7、流量控制<br>8、HTTP/1 的几种优化可以弃用<br>参考：<a href=\"https://blog.wangriyu.wang/2018/05-HTTP2.html\" target=\"_blank\" rel=\"noopener\">https://blog.wangriyu.wang/2018/05-HTTP2.html</a></li>\n</ul>\n<h3 id=\"HTTP协议在OSI模型的位置\"><a href=\"#HTTP协议在OSI模型的位置\" class=\"headerlink\" title=\"HTTP协议在OSI模型的位置\"></a>HTTP协议在OSI模型的位置</h3><p>HTTP协议位于应用层</p>\n<p><image src=\"https://bayuefen.oss-cn-hangzhou.aliyuncs.com/blog/20190406164742398.png?x-oss-process=style/compress_high\" width=\"600\" align=\"center\"></image></p>\n\n<h3 id=\"HTTP协议的method\"><a href=\"#HTTP协议的method\" class=\"headerlink\" title=\"HTTP协议的method\"></a>HTTP协议的method</h3><p>GET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.get(<span class=\"string\">'https://api.github.com/events'</span>)</span><br></pre></td></tr></table></figure>\n<p>HEAD：请求一个与GET请求的响应相同的响应，但没有响应体.</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.head(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure>\n<p>POST：用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改.<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.post(<span class=\"string\">'http://httpbin.org/post'</span>, data = &#123;<span class=\"string\">'key'</span><span class=\"symbol\">:<span class=\"string\">'value'</span></span>&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>PUT：用请求有效载荷替换目标资源的所有当前表示。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.put(<span class=\"string\">'http://httpbin.org/put'</span>, data = &#123;<span class=\"string\">'key'</span><span class=\"symbol\">:<span class=\"string\">'value'</span></span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>DELETE：删除指定的资源。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.delete(<span class=\"string\">'http://httpbin.org/delete'</span>)</span><br></pre></td></tr></table></figure>\n<p>CONNECT：建立一个到由目标资源标识的服务器的隧道。</p>\n<p>OPTIONS：用于描述目标资源的通信选项。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; r = requests.options(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure>\n<p>TRACE：沿着到目标资源的路径执行一个消息环回测试。</p>\n<p>PATCH：用于对资源应用部分修改。</p>\n<p>GET和POST对比：<br>GET<br>1.方法用途<br>GET 方法的首要目的是 获取资源</p>\n<p>2.方法特点<br>a) 参数可见<br>GET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法<br>不过也正是因此，所以 GET 方法允许被保存书签</p>\n<p>b) 数据类型只允许 ASCII<br>GET 方法的数据类型只允许是 ASCII 字符，所以说传递 二进制 文件就不可以用 GET 方法了哦</p>\n<p>c) 可以保存书签<br>当我们访问某一个网站的频率特别高的时候，肯定添加到书签，那其实书签就是依靠 GET 方法来保存的</p>\n<p>d) 可以被缓存<br>GET 方法支持缓存，当本次请求允许被缓存时，会将资源存值本地 cache ，在未过期的情况下直接取本地 cache；缓存过期后视情况而定</p>\n<p>e) 参数会保留在浏览器历史记录<br>比较直观的感受就是，我们可以在浏览器的历史记录中查看到曾经搜索过的关键字信息</p>\n<p>f) 请求长度会受限于所使用的浏览器与服务器<br>不同的浏览器对于 GET 请求长度的限制也是不同的，注意这是 浏览器 / 服务器（IE、Chrome、Apache、IIS等） 对于长度的限制，而不是 HTTP 协议</p>\n<p>POST<br>1.方法用途<br>POST 方法的首要目的是 提交，POST 方法一般用于添加资源</p>\n<p>2.方法特点<br>a) 参数不可见，也不会被保存<br>所以说 POST 方法是不可以被保存书签的</p>\n<p>b) 不能收藏为书签<br>理由如上</p>\n<p>c) 不可以被缓存<br>我要提交的数据被缓存在本地 cache 中想想其实也是没道理的</p>\n<p>d) 不会被保存在浏览器历史中<br>同样是因为参数不可见</p>\n<p>e) 不限制请求长度<br>对于 POST 方法这种以 提交 为首要目的的方法，肯定是不可以限制请求长度的</p>\n<p>f) 数据类型<br>不限，所以说 POST 是可以 提交文件 到服务器的</p>\n<p>g) 请求方式<br>POST 请求与 GET 请求不同，他会首先提交 HEAD 信息，待得到 100 响应后，才会再次将 DATA 提交</p>\n<h3 id=\"HTTP协议的组成\"><a href=\"#HTTP协议的组成\" class=\"headerlink\" title=\"HTTP协议的组成\"></a>HTTP协议的组成</h3><p>请求报文包含三部分：<br><strong>·</strong>请求行(Request line)：包含请求方法、URI、HTTP版本信息<br><strong>·</strong>请求首部字段(Request header)<br><strong>·</strong>请求内容实体<br>响应报文包含三部分：（以豆瓣电影TOP250为例）</p>\n<blockquote>\n<p>Request Headers</p>\n</blockquote>\n<blockquote>\n<p>GET /top250 HTTP/1.1<br>#GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。<br>Host: movie.douban.com<br>#表示请求的域名是movie.douban.com<br>Connection: keep-alive<br>#表示支持长连接<br>Cache-Control: max-age=0<br>#指定请求和响应遵循的缓存机制<br>Upgrade-Insecure-Requests: 1<br>#浏览器可以处理https协议<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36<br>#发出请求的用户信息<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3<br>#客户端希望接受的数据类型<br>Accept-Encoding: gzip, deflate, br<br>#浏览器发给服务器,声明浏览器支持的编码类型<br>Accept-Language: zh-CN,zh;q=0.9<br>#浏览器支持的语言分别是简体中文和中文，优先支持简体中文。<br>Cookie: bid=ZbyUzrJdS2w; <strong>utmc=30149280; </strong>utmc=223695111; <strong>yadk_uid=nTiBvU6fTOaXD90dB6edYhp8urhJwCjc; viewed=”27599884”; gr_user_id=4aa3ad30-748f-488c-b5b3-bcff3f0456d4; douban-fav-remind=1; ll=”118172”; _vwo_uuid_v2=DE51C937E99B505F3A54AE46B8619B83A|80d039133d473653fabc07636080bbb8; push_noty_num=0; push_doumail_num=0; </strong>utmv=30149280.19454; ap_v=0,6.0; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1554617137%2C%22https%3A%2F%2Fwww.<br>baidu.com%2Flink%3Furl%3Dt8BO_5f8zl_78xcE_dnmyhd_1xbKVsXtXZv_yHxp72UVO88nbOSLQSA1xMPpsfX2%26wd%3<br>D%26eqid%3Da8c4f714000c0677000000035ca9932e%22%5D;<br> _pk_id.100001.4cf6=e94317b751ae8229.1554384156.13.1554617137.1554583408.; _pk_ses.100001.4cf6=*; <strong>utma=30149280.106710662.1554384144.1554583409.1554617137.12; </strong>utmb=30149280.0.10.1554617137; <strong>utmz=30149280.1554617137.12.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; </strong>utma=223695111.1166551075.1554384156.1554583409.1554617137.13; <strong>utmb=223695111.0.10.1554617137; </strong>utmz=223695111.1554617137.13.6.utmcsr=baidu|utmccn=(organic)|utmcmd=organic<br>#http是无状态的，所以引入了cookie来管理服务器与客户端之间的状态</p>\n</blockquote>\n<p>响应报文包含三部分：<br><strong>·</strong>状态行：包含HTTP版本、状态码、状态码的原因短语<br><strong>·</strong>响应首部字段<br><strong>·</strong>响应内容实体</p>\n<blockquote>\n<p>Response header</p>\n</blockquote>\n<blockquote>\n<p>HTTP/1.1 200 OK<br>#响应状态<br>Date: Sun, 07 Apr 2019 06:05:45 GMT<br>#生成消息的具体时间和日期<br>Content-Type: text/html; charset=utf-8<br>#服务器发送 html 文档，字符集为 UTF-8<br>Transfer-Encoding: chunked<br>Connection: keep-alive<br>Keep-Alive: timeout=30<br>Vary: Accept-Encoding<br>#服务器响应时根据请求头中的的值返回不同的内容<br>X-Xss-Protection: 1; mode=block<br>设置浏览器的XSS防护机制，浏览器如果检测到恶意代码，则不渲染恶意代码<br>X-Douban-Mobileapp: 0<br>Expires: Sun, 1 Jan 2006 01:00:00 GMT<br>浏览器会在指定过期时间内使用本地缓存<br>Pragma: no-cache<br>Cache-Control: must-revalidate, no-cache, private<br>X-DAE-Node: brand4<br>X-DAE-App: movie<br>Server: dae<br>X-Content-Type-Options: nosniff<br>Content-Encoding: gzip<br>文档使用的 MIME 类型是 text/html，并且对内容进行了 gzip 压缩</p>\n</blockquote>\n<h3 id=\"HTTP协议的状态码\"><a href=\"#HTTP协议的状态码\" class=\"headerlink\" title=\"HTTP协议的状态码\"></a>HTTP协议的状态码</h3><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。<br>2xx （成功） 表示成功处理了请求的状态代码。<br>3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。<br>4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。<br>5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。<br>常见的：200 – 服务器成功返回网页 |404 – 请求的网页不存在 |503 – 服务不可用 </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">状态码</th>\n<th style=\"text-align:center\">中文描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">101</td>\n<td style=\"text-align:center\">（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">102</td>\n<td style=\"text-align:center\">（已接受）已经接受请求，但未处理完成</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">200</td>\n<td style=\"text-align:center\">（成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">201</td>\n<td style=\"text-align:center\">（已创建）  请求成功并且服务器创建了新的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">202</td>\n<td style=\"text-align:center\">（已接受）  服务器已接受请求，但尚未处理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">203</td>\n<td style=\"text-align:center\">（非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">204</td>\n<td style=\"text-align:center\">（无内容）  服务器成功处理了请求，但没有返回任何内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">205</td>\n<td style=\"text-align:center\">（重置内容） 服务器成功处理了请求，但没有返回任何内容。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">206</td>\n<td style=\"text-align:center\">（部分内容）  服务器成功处理了部分 GET 请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">300</td>\n<td style=\"text-align:center\">（多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">301</td>\n<td style=\"text-align:center\">（永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">302</td>\n<td style=\"text-align:center\">（临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">303</td>\n<td style=\"text-align:center\">（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">304</td>\n<td style=\"text-align:center\">（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">305</td>\n<td style=\"text-align:center\">（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">307</td>\n<td style=\"text-align:center\">（临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">400</td>\n<td style=\"text-align:center\">（错误请求） 服务器不理解请求的语法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">401</td>\n<td style=\"text-align:center\">未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">403</td>\n<td style=\"text-align:center\">（禁止） 服务器拒绝请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">404</td>\n<td style=\"text-align:center\">（未找到） 服务器找不到请求的网页。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">405</td>\n<td style=\"text-align:center\">（方法禁用） 禁用请求中指定的方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">406</td>\n<td style=\"text-align:center\">（不接受） 无法使用请求的内容特性响应请求的网页。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">407</td>\n<td style=\"text-align:center\">（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">408</td>\n<td style=\"text-align:center\">（请求超时）  服务器等候请求时发生超时。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">409</td>\n<td style=\"text-align:center\">（冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">410</td>\n<td style=\"text-align:center\">（已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">411</td>\n<td style=\"text-align:center\">（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">412</td>\n<td style=\"text-align:center\">（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">413</td>\n<td style=\"text-align:center\">（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">414</td>\n<td style=\"text-align:center\">（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">415</td>\n<td style=\"text-align:center\">（不支持的媒体类型） 请求的格式不受请求页面的支持。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">416</td>\n<td style=\"text-align:center\">（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">417</td>\n<td style=\"text-align:center\">（未满足期望值） 服务器未满足”期望”请求标头字段的要求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">（服务器内部错误）  服务器遇到错误，无法完成请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">501</td>\n<td style=\"text-align:center\">（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">502</td>\n<td style=\"text-align:center\">（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">503</td>\n<td style=\"text-align:center\">（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">504</td>\n<td style=\"text-align:center\">（网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">505</td>\n<td style=\"text-align:center\">（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"cookies和会话\"><a href=\"#cookies和会话\" class=\"headerlink\" title=\"cookies和会话\"></a>cookies和会话</h3><p>因为HTTP是无状态的，对事物处理没有记忆能力。cookies和会话出现用于保持HTTP连接状态，<br>会话在服务端，用来保存用户的会话信息；cookies在客户端，浏览器下次访问网页时会自动附带上它发送给服务器，<br>服务器通过识别cookies找到对应的会话判断用户状态。<br>PS:关闭浏览器不会导致会话被删除，反而没有存储到硬盘上的cookie会消失，因此为了节省存储空间需要为会话设置一个失效时间。</p>"},{"title":"辨析 Sass 中的 Map 和 List","date":"2015-10-21T02:34:12.000Z","_content":"\n如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。\n\n自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。\n\n那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 `package.json` 或者其他同类型的项目配置文件所控制，往往只需一条命令（`gem update sass`）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。\n\n<!-- more -->\n\n使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。\n\n## 测试表格\n\nVariable | Description\n--- | ---\n`site` | Sitewide information.\n`page` | Page specific information and custom variables set in front-matter.\n`config` | Site configuration\n`theme` | Theme configuration. Inherits from site configuration.\n`_` (single underscore) | [Lodash](http://lodash.com/) library\n`path` | Path of current page\n`url` | Full URL of current page\n`env` | Environment variables\n\n\n## 语法比较\n\n<div class=\"note\">\n    <h5>测试标题</h5>\n    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p>\n</div>\n\n#### Map 语法\n\n下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。\n\n```sass\n$breakpoint-map: (\n    small: (\n        min-width: null,\n        max-width: 479px,\n        base-font: 16px,\n        vertical-rhythm: 1.3\n    ),\n    medium: (\n        min-width: 480px,\n        max-width: 959px,\n        base-font: 18px,\n        vertical-rhythm: 1.414\n    ),\n    large: (\n        min-width: 960px,\n        max-width: 1099px,\n        base-font: 18px,\n        vertical-rhythm: 1.5\n    ),\n    xlarge: (\n        min-width: 1100px,\n        max-width: null,\n        base-font: 21px,\n        vertical-rhythm: 1.618\n    )\n);\n```\n\n#### 多重列表语法\n\n下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 `nth()` 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, null, 21px, 1.618)\n);\n```\n\n## 遍历比较\n\n<div class=\"note info\">\n    <h5>测试标题</h5>\n    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p>\n</div>\n\n#### 遍历 Map\n\n我们可以使用如下的代码遍历 Map：\n\n```sass\n@each $label, $map in $breakpoint-map {}\n```\n\n这里的变量 `$label` 和 `$map` 会随着对 `$breakpoint-map` 的遍历被动态地赋值，`$label` 将会被赋值为 `$breakpoint-map` 的 Key，而 `$map` 会被赋值为 `$breakpoint-map` 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 `map-get()` 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。\n\n具体的做法就是使用 `@each` 遍历 Map，然后使用 `map-get()` 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：\n\n```sass\n@each $label, $map in $breakpoint-map {\n    $min-width: map-get($map, min-width);\n    $max-width: map-get($map, max-width);\n    $base-font: map-get($map, base-font);\n    $vertical-rhythm: map-get($map, vertical-rhythm);\n}\n```\n\n#### 遍历多重列表\n\n遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 `map-get()` 函数取特定值，直接遍历一遍即可获得特定值。\n\n因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 `map-get()`，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：\n\n```sass\n@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n}\n```\n\n## 慎用多重列表\n\n<div class=\"note warning\">\n    <h5>测试标题</h5>\n    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p>\n</div>\n\n#### 遗漏键值\n\n如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, 21px, 1.618)\n);\n\np {\n    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n        @if $min-width {\n            @include breakpoint( $min-width ) {\n                font-size: $base-font;\n                line-height: $vertical-rhythm;\n            }\n        } @else {\n            font-size: $base-font;\n            line-height: $vertical-rhythm;\n        }\n    }\n}\n```\n\n当我们尝试运行这段代码时，结果肯定是错误地，因为在 `$breakpoint-list` 的最后一行，`xlarge` 被赋值给了 `$label`，`1100px` 被赋值给了 `$min-width`，`21px` 被赋值给了 `$max-width`, `1.618` 被赋值给了 `$base-font`，最终导致 `$vertical-rhythm` 没有被赋值，结果就是 `font-size` 的属性值是错的，`line-height` 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。\n\n如果我们使用 Map 来代替这里的多重列表，那么使用 `map-get()` 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。\n\n#### 查找特定列表\n\n在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 `map-get()` 函数可以快速定位到特定子 Map：\n\n```sass\n$medium-map: map-get($maps, medium);\n```\n\n但如果要获取多种列表 `medium` 列表，麻烦可就大了：\n\n```sass\n@function get-list($label) {\n    @each $list in $breakpoint-list {\n        @if nth($list, 1) == $label {\n            @return $list;\n        }\n    }\n    @return null;\n}\n$medium-list: get-list(medium);\n```\n\n这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 `null`。这实际上就是手工实现了 `map-get()` 的逻辑。\n\n#### 缺少原生的 Map 函数\n\nSass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 `map-merge()` 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 `join()` 或 `append()` 来增加新列表，从而模拟出 `map-merge()` 的效果。\n\n另一个实用的 Map 函数就是 `map-has-key()`，对于依赖 `map-get()` 的自定义函数来说，`map-has-key()` 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。\n\n## 总结\n\n<div class=\"note unreleased\">\n    <h5>Test Title</h5>\n    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p>\n</div>\n\n虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。\n","source":"_posts/demo.md","raw":"title: 辨析 Sass 中的 Map 和 List\ndate: 2015-10-21 10:34:12\ntags:\n- css\n---\n\n如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。\n\n自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。\n\n那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 `package.json` 或者其他同类型的项目配置文件所控制，往往只需一条命令（`gem update sass`）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。\n\n<!-- more -->\n\n使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。\n\n## 测试表格\n\nVariable | Description\n--- | ---\n`site` | Sitewide information.\n`page` | Page specific information and custom variables set in front-matter.\n`config` | Site configuration\n`theme` | Theme configuration. Inherits from site configuration.\n`_` (single underscore) | [Lodash](http://lodash.com/) library\n`path` | Path of current page\n`url` | Full URL of current page\n`env` | Environment variables\n\n\n## 语法比较\n\n<div class=\"note\">\n    <h5>测试标题</h5>\n    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p>\n</div>\n\n#### Map 语法\n\n下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。\n\n```sass\n$breakpoint-map: (\n    small: (\n        min-width: null,\n        max-width: 479px,\n        base-font: 16px,\n        vertical-rhythm: 1.3\n    ),\n    medium: (\n        min-width: 480px,\n        max-width: 959px,\n        base-font: 18px,\n        vertical-rhythm: 1.414\n    ),\n    large: (\n        min-width: 960px,\n        max-width: 1099px,\n        base-font: 18px,\n        vertical-rhythm: 1.5\n    ),\n    xlarge: (\n        min-width: 1100px,\n        max-width: null,\n        base-font: 21px,\n        vertical-rhythm: 1.618\n    )\n);\n```\n\n#### 多重列表语法\n\n下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 `nth()` 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, null, 21px, 1.618)\n);\n```\n\n## 遍历比较\n\n<div class=\"note info\">\n    <h5>测试标题</h5>\n    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p>\n</div>\n\n#### 遍历 Map\n\n我们可以使用如下的代码遍历 Map：\n\n```sass\n@each $label, $map in $breakpoint-map {}\n```\n\n这里的变量 `$label` 和 `$map` 会随着对 `$breakpoint-map` 的遍历被动态地赋值，`$label` 将会被赋值为 `$breakpoint-map` 的 Key，而 `$map` 会被赋值为 `$breakpoint-map` 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 `map-get()` 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。\n\n具体的做法就是使用 `@each` 遍历 Map，然后使用 `map-get()` 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：\n\n```sass\n@each $label, $map in $breakpoint-map {\n    $min-width: map-get($map, min-width);\n    $max-width: map-get($map, max-width);\n    $base-font: map-get($map, base-font);\n    $vertical-rhythm: map-get($map, vertical-rhythm);\n}\n```\n\n#### 遍历多重列表\n\n遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 `map-get()` 函数取特定值，直接遍历一遍即可获得特定值。\n\n因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 `map-get()`，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：\n\n```sass\n@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n}\n```\n\n## 慎用多重列表\n\n<div class=\"note warning\">\n    <h5>测试标题</h5>\n    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p>\n</div>\n\n#### 遗漏键值\n\n如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：\n\n```sass\n$breakpoint-list: (\n    (small, null, 479px, 16px, 1.3),\n    (medium, 480px, 959px, 18px, 1.414),\n    (large, 960px, 1099px, 18px, 1.5),\n    (xlarge, 1100px, 21px, 1.618)\n);\n\np {\n    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list {\n        @if $min-width {\n            @include breakpoint( $min-width ) {\n                font-size: $base-font;\n                line-height: $vertical-rhythm;\n            }\n        } @else {\n            font-size: $base-font;\n            line-height: $vertical-rhythm;\n        }\n    }\n}\n```\n\n当我们尝试运行这段代码时，结果肯定是错误地，因为在 `$breakpoint-list` 的最后一行，`xlarge` 被赋值给了 `$label`，`1100px` 被赋值给了 `$min-width`，`21px` 被赋值给了 `$max-width`, `1.618` 被赋值给了 `$base-font`，最终导致 `$vertical-rhythm` 没有被赋值，结果就是 `font-size` 的属性值是错的，`line-height` 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。\n\n如果我们使用 Map 来代替这里的多重列表，那么使用 `map-get()` 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。\n\n#### 查找特定列表\n\n在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 `map-get()` 函数可以快速定位到特定子 Map：\n\n```sass\n$medium-map: map-get($maps, medium);\n```\n\n但如果要获取多种列表 `medium` 列表，麻烦可就大了：\n\n```sass\n@function get-list($label) {\n    @each $list in $breakpoint-list {\n        @if nth($list, 1) == $label {\n            @return $list;\n        }\n    }\n    @return null;\n}\n$medium-list: get-list(medium);\n```\n\n这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 `null`。这实际上就是手工实现了 `map-get()` 的逻辑。\n\n#### 缺少原生的 Map 函数\n\nSass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 `map-merge()` 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 `join()` 或 `append()` 来增加新列表，从而模拟出 `map-merge()` 的效果。\n\n另一个实用的 Map 函数就是 `map-has-key()`，对于依赖 `map-get()` 的自定义函数来说，`map-has-key()` 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。\n\n## 总结\n\n<div class=\"note unreleased\">\n    <h5>Test Title</h5>\n    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p>\n</div>\n\n虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。\n","slug":"demo","published":1,"updated":"2019-04-07T05:45:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjur15bao00032o1aewqqdzv3","content":"<p>如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。</p>\n<p>自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。</p>\n<p>那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 <code>package.json</code> 或者其他同类型的项目配置文件所控制，往往只需一条命令（<code>gem update sass</code>）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。</p>\n<a id=\"more\"></a>\n<p>使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。</p>\n<h2 id=\"测试表格\"><a href=\"#测试表格\" class=\"headerlink\" title=\"测试表格\"></a>测试表格</h2><table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>site</code></td>\n<td>Sitewide information.</td>\n</tr>\n<tr>\n<td><code>page</code></td>\n<td>Page specific information and custom variables set in front-matter.</td>\n</tr>\n<tr>\n<td><code>config</code></td>\n<td>Site configuration</td>\n</tr>\n<tr>\n<td><code>theme</code></td>\n<td>Theme configuration. Inherits from site configuration.</td>\n</tr>\n<tr>\n<td><code>_</code> (single underscore)</td>\n<td><a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a> library</td>\n</tr>\n<tr>\n<td><code>path</code></td>\n<td>Path of current page</td>\n</tr>\n<tr>\n<td><code>url</code></td>\n<td>Full URL of current page</td>\n</tr>\n<tr>\n<td><code>env</code></td>\n<td>Environment variables</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"语法比较\"><a href=\"#语法比较\" class=\"headerlink\" title=\"语法比较\"></a>语法比较</h2><div class=\"note\"><br>    <h5>测试标题</h5><br>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 <code>min-width</code>、<code>max-width</code>、<code>font-size</code> 和 <code>line-height</code> 四个样式。</p><br></div>\n\n<h4 id=\"Map-语法\"><a href=\"#Map-语法\" class=\"headerlink\" title=\"Map 语法\"></a>Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-map: (</span><br><span class=\"line\">    small: (</span><br><span class=\"line\">        min-width: null,</span><br><span class=\"line\">        max-width: 479px,</span><br><span class=\"line\">        base-font: 16px,</span><br><span class=\"line\">        vertical-rhythm: 1.3</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    medium: (</span><br><span class=\"line\">        min-width: 480px,</span><br><span class=\"line\">        max-width: 959px,</span><br><span class=\"line\">        base-font: 18px,</span><br><span class=\"line\">        vertical-rhythm: 1.414</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    large: (</span><br><span class=\"line\">        min-width: 960px,</span><br><span class=\"line\">        max-width: 1099px,</span><br><span class=\"line\">        base-font: 18px,</span><br><span class=\"line\">        vertical-rhythm: 1.5</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    xlarge: (</span><br><span class=\"line\">        min-width: 1100px,</span><br><span class=\"line\">        max-width: null,</span><br><span class=\"line\">        base-font: 21px,</span><br><span class=\"line\">        vertical-rhythm: 1.618</span><br><span class=\"line\">    )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"多重列表语法\"><a href=\"#多重列表语法\" class=\"headerlink\" title=\"多重列表语法\"></a>多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-list: (</span><br><span class=\"line\">    (small, null, 479px, 16px, 1.3),</span><br><span class=\"line\">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class=\"line\">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class=\"line\">    (xlarge, 1100px, null, 21px, 1.618)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历比较\"><a href=\"#遍历比较\" class=\"headerlink\" title=\"遍历比较\"></a>遍历比较</h2><div class=\"note info\"><br>    <h5>测试标题</h5><br>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p><br></div>\n\n<h4 id=\"遍历-Map\"><a href=\"#遍历-Map\" class=\"headerlink\" title=\"遍历 Map\"></a>遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $map in $breakpoint-map &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p>\n<p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $map in $breakpoint-map &#123;</span><br><span class=\"line\">    $min-width: map-get($map, min-width);</span><br><span class=\"line\">    $max-width: map-get($map, max-width);</span><br><span class=\"line\">    $base-font: map-get($map, base-font);</span><br><span class=\"line\">    $vertical-rhythm: map-get($map, vertical-rhythm);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"遍历多重列表\"><a href=\"#遍历多重列表\" class=\"headerlink\" title=\"遍历多重列表\"></a>遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p>\n<p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"慎用多重列表\"><a href=\"#慎用多重列表\" class=\"headerlink\" title=\"慎用多重列表\"></a>慎用多重列表</h2><div class=\"note warning\"><br>    <h5>测试标题</h5><br>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p><br></div>\n\n<h4 id=\"遗漏键值\"><a href=\"#遗漏键值\" class=\"headerlink\" title=\"遗漏键值\"></a>遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-list: (</span><br><span class=\"line\">    (small, null, 479px, 16px, 1.3),</span><br><span class=\"line\">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class=\"line\">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class=\"line\">    (xlarge, 1100px, 21px, 1.618)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">p &#123;</span><br><span class=\"line\">    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class=\"line\">        @if $min-width &#123;</span><br><span class=\"line\">            @include breakpoint( $min-width ) &#123;</span><br><span class=\"line\">                font-size: $base-font;</span><br><span class=\"line\">                line-height: $vertical-rhythm;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; @else &#123;</span><br><span class=\"line\">            font-size: $base-font;</span><br><span class=\"line\">            line-height: $vertical-rhythm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p>\n<p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p>\n<h4 id=\"查找特定列表\"><a href=\"#查找特定列表\" class=\"headerlink\" title=\"查找特定列表\"></a>查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$medium-map: map-get($maps, medium);</span><br></pre></td></tr></table></figure>\n<p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function get-list($label) &#123;</span><br><span class=\"line\">    @each $list in $breakpoint-list &#123;</span><br><span class=\"line\">        @if nth($list, 1) == $label &#123;</span><br><span class=\"line\">            @return $list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$medium-list: get-list(medium);</span><br></pre></td></tr></table></figure>\n<p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p>\n<h4 id=\"缺少原生的-Map-函数\"><a href=\"#缺少原生的-Map-函数\" class=\"headerlink\" title=\"缺少原生的 Map 函数\"></a>缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p>\n<p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><div class=\"note unreleased\"><br>    <h5>Test Title</h5><br>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p><br></div>\n\n<p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>\n","site":{"data":{}},"excerpt":"<p>如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。</p>\n<p>自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。</p>\n<p>那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 <code>package.json</code> 或者其他同类型的项目配置文件所控制，往往只需一条命令（<code>gem update sass</code>）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。</p>","more":"<p>使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。</p>\n<h2 id=\"测试表格\"><a href=\"#测试表格\" class=\"headerlink\" title=\"测试表格\"></a>测试表格</h2><table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>site</code></td>\n<td>Sitewide information.</td>\n</tr>\n<tr>\n<td><code>page</code></td>\n<td>Page specific information and custom variables set in front-matter.</td>\n</tr>\n<tr>\n<td><code>config</code></td>\n<td>Site configuration</td>\n</tr>\n<tr>\n<td><code>theme</code></td>\n<td>Theme configuration. Inherits from site configuration.</td>\n</tr>\n<tr>\n<td><code>_</code> (single underscore)</td>\n<td><a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a> library</td>\n</tr>\n<tr>\n<td><code>path</code></td>\n<td>Path of current page</td>\n</tr>\n<tr>\n<td><code>url</code></td>\n<td>Full URL of current page</td>\n</tr>\n<tr>\n<td><code>env</code></td>\n<td>Environment variables</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"语法比较\"><a href=\"#语法比较\" class=\"headerlink\" title=\"语法比较\"></a>语法比较</h2><div class=\"note\"><br>    <h5>测试标题</h5><br>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 <code>min-width</code>、<code>max-width</code>、<code>font-size</code> 和 <code>line-height</code> 四个样式。</p><br></div>\n\n<h4 id=\"Map-语法\"><a href=\"#Map-语法\" class=\"headerlink\" title=\"Map 语法\"></a>Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-map: (</span><br><span class=\"line\">    small: (</span><br><span class=\"line\">        min-width: null,</span><br><span class=\"line\">        max-width: 479px,</span><br><span class=\"line\">        base-font: 16px,</span><br><span class=\"line\">        vertical-rhythm: 1.3</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    medium: (</span><br><span class=\"line\">        min-width: 480px,</span><br><span class=\"line\">        max-width: 959px,</span><br><span class=\"line\">        base-font: 18px,</span><br><span class=\"line\">        vertical-rhythm: 1.414</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    large: (</span><br><span class=\"line\">        min-width: 960px,</span><br><span class=\"line\">        max-width: 1099px,</span><br><span class=\"line\">        base-font: 18px,</span><br><span class=\"line\">        vertical-rhythm: 1.5</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    xlarge: (</span><br><span class=\"line\">        min-width: 1100px,</span><br><span class=\"line\">        max-width: null,</span><br><span class=\"line\">        base-font: 21px,</span><br><span class=\"line\">        vertical-rhythm: 1.618</span><br><span class=\"line\">    )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"多重列表语法\"><a href=\"#多重列表语法\" class=\"headerlink\" title=\"多重列表语法\"></a>多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-list: (</span><br><span class=\"line\">    (small, null, 479px, 16px, 1.3),</span><br><span class=\"line\">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class=\"line\">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class=\"line\">    (xlarge, 1100px, null, 21px, 1.618)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历比较\"><a href=\"#遍历比较\" class=\"headerlink\" title=\"遍历比较\"></a>遍历比较</h2><div class=\"note info\"><br>    <h5>测试标题</h5><br>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p><br></div>\n\n<h4 id=\"遍历-Map\"><a href=\"#遍历-Map\" class=\"headerlink\" title=\"遍历 Map\"></a>遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $map in $breakpoint-map &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p>\n<p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $map in $breakpoint-map &#123;</span><br><span class=\"line\">    $min-width: map-get($map, min-width);</span><br><span class=\"line\">    $max-width: map-get($map, max-width);</span><br><span class=\"line\">    $base-font: map-get($map, base-font);</span><br><span class=\"line\">    $vertical-rhythm: map-get($map, vertical-rhythm);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"遍历多重列表\"><a href=\"#遍历多重列表\" class=\"headerlink\" title=\"遍历多重列表\"></a>遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p>\n<p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"慎用多重列表\"><a href=\"#慎用多重列表\" class=\"headerlink\" title=\"慎用多重列表\"></a>慎用多重列表</h2><div class=\"note warning\"><br>    <h5>测试标题</h5><br>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p><br></div>\n\n<h4 id=\"遗漏键值\"><a href=\"#遗漏键值\" class=\"headerlink\" title=\"遗漏键值\"></a>遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$breakpoint-list: (</span><br><span class=\"line\">    (small, null, 479px, 16px, 1.3),</span><br><span class=\"line\">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class=\"line\">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class=\"line\">    (xlarge, 1100px, 21px, 1.618)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">p &#123;</span><br><span class=\"line\">    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class=\"line\">        @if $min-width &#123;</span><br><span class=\"line\">            @include breakpoint( $min-width ) &#123;</span><br><span class=\"line\">                font-size: $base-font;</span><br><span class=\"line\">                line-height: $vertical-rhythm;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; @else &#123;</span><br><span class=\"line\">            font-size: $base-font;</span><br><span class=\"line\">            line-height: $vertical-rhythm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p>\n<p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p>\n<h4 id=\"查找特定列表\"><a href=\"#查找特定列表\" class=\"headerlink\" title=\"查找特定列表\"></a>查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$medium-map: map-get($maps, medium);</span><br></pre></td></tr></table></figure>\n<p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function get-list($label) &#123;</span><br><span class=\"line\">    @each $list in $breakpoint-list &#123;</span><br><span class=\"line\">        @if nth($list, 1) == $label &#123;</span><br><span class=\"line\">            @return $list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$medium-list: get-list(medium);</span><br></pre></td></tr></table></figure>\n<p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p>\n<h4 id=\"缺少原生的-Map-函数\"><a href=\"#缺少原生的-Map-函数\" class=\"headerlink\" title=\"缺少原生的 Map 函数\"></a>缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p>\n<p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><div class=\"note unreleased\"><br>    <h5>Test Title</h5><br>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p><br></div>\n\n<p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>"},{"title":"【python】三方模块requests入门应用","date":"2019-04-17T05:47:08.000Z","_content":"本文基于`python3.7`及第三方模块`requests`编写入门级简易模式的HTTP请求应用于详解。\n`requests`是由python编写,基于urllib, 采用Apache2 Licensed开源协议的HTTP三方模块。详情应用见[官网](http://docs.python-requests.org/zh_CN/latest/index.html)\n\n<!-- more -->\n\n## 安装\n> 1. 如果已安装Anaconda，默认是含`requests`模块。\n> 2. 终端命令行安装，[详情](http://docs.python-requests.org/zh_CN/latest/user/install.html#install)\n    ````\n    pip install requests\n    ````\n    \n## 应用\n\n\n````\nimport requests\nimport logging\nimport json\nfrom requests.auth import AuthBase\n\ndomain = 'http://httpbin.org'\n````\n\n#### GET\n````\nres = requests.get(domain + '/get', params={'aa': 1, 'bb': 2})\nprint(res.status_code, res.text)\nprint(res.url, res.json())\n````\n\n#### POST\n````\nres = requests.post(domain + '/post', params={'aa': 11, 'bb': 22}, data={'username': 'bayuefen', 'password': '123456'})\nprint(res.status_code, res.text)\nprint(res.url, res.json())\n````\n\n#### PATCH\n````\nres = requests.patch(domain + '/patch', data={'username':'bayuefen','password':'123456','visibility':'private'})\nprint(res.status_code, res.text)\nprint(res.headers)\n````\n\n#### DELETE\n````\nres = requests.delete(domain + '/delete')\nprint(res.status_code, res.text)\nprint(res.headers)\n````\n\n#### Session (⭐️⭐️⭐️)\n````\nrs = requests.Session()\nrs.get(domain + '/cookies/set/username/bayuefen')\nres = rs.get(domain + '/cookies')\nprint(res.text)\n````\n> 1.Session对象能够跨请求保持某些特定参数，并且同一个Session实例发出的所有请求之间保持cookie\n> 2.对于同一个服务器发送多个请求，底层TCP连接可被重用，有显著的性能提升\n\n#### Cookie  (⭐️⭐️⭐️)\n````\ncookies = dict(admin_token='xxxxxxxxx')\nres = requests.get(domain + '/cookies/set', cookies=cookies)\nprint(res.text)\n````\n\n````\njar = requests.cookies.RequestsCookieJar()\njar.set('bayuefen_cookies', '123456', domain='httpbin.org', path='/cookies')\njar.set('bayuefen_values', 'my_values', domain='httpbin.org', path='/elsewhere')\nres1 = requests.get(domain + '/cookies', cookies=jar)\nprint(res1.text)\n````\n> Cookie的返回对象是RequestsCookieJar，这种模式适用于跨域名跨路径使用\n\n#### redirect\n````\nres = requests.get(domain + '/redirect-to', params={'url':'https://www.baidu.com', 'status_code':302})\nprint(res.url, res.status_code)\nprint(res.history)\n````\n> 可配置allow_redirects = False 禁用重定向\n\n#### timeout\n````\nres = requests.get(domain + '/get', timeout=0.001)\nprint(res.raise_for_status())\n````\n> 超时的异常触发仅仅针对连接过程，与相应体的下载无关，即请求发起至服务器相应的最大时间，超过则以异常处理\n\n#### file upload\n````\nfile = {'txtFile': open('./test.txt', 'rb')}\nupload_data = {\"parentId\": \"\", \"fileCategory\": \"personal\", \"fileSize\": 179, \"fileName\": \"test.txt\", \"uoType\": 1}\nres = requests.post(domain + '/post', upload_data, files=file)\nprint(res.url, res.status_code)\nprint(res.json())\n````\n> 超大文件的传输使用multipart/form-data，默认情况下requests是不支持的，需要使用requests-toolbelt\n\n\n#### file download\n````\nres = requests.get(domain + '/image/jpeg', stream=True)\nprint(res.raw, res.raw.read(10))\nwith open('./test.jpeg', 'wb') as f:\n    f.write(res.content)\n````\n> notice: 下载原始相应内容（images/xlsx/pdf等），通过设置stream获取raw\n#### JSON解码器\n````\nres = requests.post(domain + '/post', data={'aa': 11, 'bb': 2})\nprint(res.raise_for_status(), res.status_code)\ntry:\n    res.json()\nexcept ValueError:\n    logging.error('No JSON object could be decoded')\n````\n> JSON被解码返回成功，不一定代表HTTP相应成功；检查请求响应是否成功，需通过`response.raise_for_status()` or `response.status_code`去判别\n\n\n#### 定制 headers\n````\nheaders = {\n    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'\n}\nres = requests.get(domain + '/get', headers=headers)\nprint(res.json())\n# 响应头\nprint(res.headers.get('content-type'))\n````\n> 定制headers低于特定场景的信息源\n> 1. 如果在 .netrc 中设置了用户认证信息，使用 headers= 设置的授权就不会生效。而如果设置了 auth= 参数，``.netrc`` 的设置就无效了。\n> 2. 如果被重定向到别的主机，授权 header 就会被删除。\n> 3. 代理授权 header 会被 URL 中提供的代理身份覆盖掉。\n> 4. 在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。\n\n#### SSL\n````\nrequests.get('https://github.com', verify=True)\n````\n\n#### 流式请求\n````\nres = requests.get(domain + '/stream/20', stream=True)\nprint(res.raw)\nif res.encoding is None:\n    res.encoding = 'utf-8'\nfor line in res.iter_lines():\n    if line:\n        decoded_line = line.decode('utf-8')\n        print(json.loads(decoded_line))\n````\n\n#### Auth HTTP基本身份认证\n````\nauth = requests.auth.HTTPBasicAuth('user', 'passwd')\nres = requests.get(domain + '/hidden-basic-auth/user/passwd', auth=auth)\nprint(res.json())\n````\n\n## 参考资料\n1.[Requests: 让 HTTP 服务人类](http://docs.python-requests.org/zh_CN/latest/index.html#)\n2.[httpbin](http://httpbin.org/)\n3.[code](https://github.com/bayuefen/demos/blob/master/requestDemo/test.py)","source":"_posts/python-module-requests.md","raw":"---\ntitle: 【python】三方模块requests入门应用\ndate: 2019-04-17 13:47:08\ntags:\n    - python\n    - requests\n    - 日记\n---\n本文基于`python3.7`及第三方模块`requests`编写入门级简易模式的HTTP请求应用于详解。\n`requests`是由python编写,基于urllib, 采用Apache2 Licensed开源协议的HTTP三方模块。详情应用见[官网](http://docs.python-requests.org/zh_CN/latest/index.html)\n\n<!-- more -->\n\n## 安装\n> 1. 如果已安装Anaconda，默认是含`requests`模块。\n> 2. 终端命令行安装，[详情](http://docs.python-requests.org/zh_CN/latest/user/install.html#install)\n    ````\n    pip install requests\n    ````\n    \n## 应用\n\n\n````\nimport requests\nimport logging\nimport json\nfrom requests.auth import AuthBase\n\ndomain = 'http://httpbin.org'\n````\n\n#### GET\n````\nres = requests.get(domain + '/get', params={'aa': 1, 'bb': 2})\nprint(res.status_code, res.text)\nprint(res.url, res.json())\n````\n\n#### POST\n````\nres = requests.post(domain + '/post', params={'aa': 11, 'bb': 22}, data={'username': 'bayuefen', 'password': '123456'})\nprint(res.status_code, res.text)\nprint(res.url, res.json())\n````\n\n#### PATCH\n````\nres = requests.patch(domain + '/patch', data={'username':'bayuefen','password':'123456','visibility':'private'})\nprint(res.status_code, res.text)\nprint(res.headers)\n````\n\n#### DELETE\n````\nres = requests.delete(domain + '/delete')\nprint(res.status_code, res.text)\nprint(res.headers)\n````\n\n#### Session (⭐️⭐️⭐️)\n````\nrs = requests.Session()\nrs.get(domain + '/cookies/set/username/bayuefen')\nres = rs.get(domain + '/cookies')\nprint(res.text)\n````\n> 1.Session对象能够跨请求保持某些特定参数，并且同一个Session实例发出的所有请求之间保持cookie\n> 2.对于同一个服务器发送多个请求，底层TCP连接可被重用，有显著的性能提升\n\n#### Cookie  (⭐️⭐️⭐️)\n````\ncookies = dict(admin_token='xxxxxxxxx')\nres = requests.get(domain + '/cookies/set', cookies=cookies)\nprint(res.text)\n````\n\n````\njar = requests.cookies.RequestsCookieJar()\njar.set('bayuefen_cookies', '123456', domain='httpbin.org', path='/cookies')\njar.set('bayuefen_values', 'my_values', domain='httpbin.org', path='/elsewhere')\nres1 = requests.get(domain + '/cookies', cookies=jar)\nprint(res1.text)\n````\n> Cookie的返回对象是RequestsCookieJar，这种模式适用于跨域名跨路径使用\n\n#### redirect\n````\nres = requests.get(domain + '/redirect-to', params={'url':'https://www.baidu.com', 'status_code':302})\nprint(res.url, res.status_code)\nprint(res.history)\n````\n> 可配置allow_redirects = False 禁用重定向\n\n#### timeout\n````\nres = requests.get(domain + '/get', timeout=0.001)\nprint(res.raise_for_status())\n````\n> 超时的异常触发仅仅针对连接过程，与相应体的下载无关，即请求发起至服务器相应的最大时间，超过则以异常处理\n\n#### file upload\n````\nfile = {'txtFile': open('./test.txt', 'rb')}\nupload_data = {\"parentId\": \"\", \"fileCategory\": \"personal\", \"fileSize\": 179, \"fileName\": \"test.txt\", \"uoType\": 1}\nres = requests.post(domain + '/post', upload_data, files=file)\nprint(res.url, res.status_code)\nprint(res.json())\n````\n> 超大文件的传输使用multipart/form-data，默认情况下requests是不支持的，需要使用requests-toolbelt\n\n\n#### file download\n````\nres = requests.get(domain + '/image/jpeg', stream=True)\nprint(res.raw, res.raw.read(10))\nwith open('./test.jpeg', 'wb') as f:\n    f.write(res.content)\n````\n> notice: 下载原始相应内容（images/xlsx/pdf等），通过设置stream获取raw\n#### JSON解码器\n````\nres = requests.post(domain + '/post', data={'aa': 11, 'bb': 2})\nprint(res.raise_for_status(), res.status_code)\ntry:\n    res.json()\nexcept ValueError:\n    logging.error('No JSON object could be decoded')\n````\n> JSON被解码返回成功，不一定代表HTTP相应成功；检查请求响应是否成功，需通过`response.raise_for_status()` or `response.status_code`去判别\n\n\n#### 定制 headers\n````\nheaders = {\n    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'\n}\nres = requests.get(domain + '/get', headers=headers)\nprint(res.json())\n# 响应头\nprint(res.headers.get('content-type'))\n````\n> 定制headers低于特定场景的信息源\n> 1. 如果在 .netrc 中设置了用户认证信息，使用 headers= 设置的授权就不会生效。而如果设置了 auth= 参数，``.netrc`` 的设置就无效了。\n> 2. 如果被重定向到别的主机，授权 header 就会被删除。\n> 3. 代理授权 header 会被 URL 中提供的代理身份覆盖掉。\n> 4. 在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。\n\n#### SSL\n````\nrequests.get('https://github.com', verify=True)\n````\n\n#### 流式请求\n````\nres = requests.get(domain + '/stream/20', stream=True)\nprint(res.raw)\nif res.encoding is None:\n    res.encoding = 'utf-8'\nfor line in res.iter_lines():\n    if line:\n        decoded_line = line.decode('utf-8')\n        print(json.loads(decoded_line))\n````\n\n#### Auth HTTP基本身份认证\n````\nauth = requests.auth.HTTPBasicAuth('user', 'passwd')\nres = requests.get(domain + '/hidden-basic-auth/user/passwd', auth=auth)\nprint(res.json())\n````\n\n## 参考资料\n1.[Requests: 让 HTTP 服务人类](http://docs.python-requests.org/zh_CN/latest/index.html#)\n2.[httpbin](http://httpbin.org/)\n3.[code](https://github.com/bayuefen/demos/blob/master/requestDemo/test.py)","slug":"python-module-requests","published":1,"updated":"2019-04-17T07:29:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjur15baq00042o1a29j528es","content":"<p>本文基于<code>python3.7</code>及第三方模块<code>requests</code>编写入门级简易模式的HTTP请求应用于详解。<br><code>requests</code>是由python编写,基于urllib, 采用Apache2 Licensed开源协议的HTTP三方模块。详情应用见<a href=\"http://docs.python-requests.org/zh_CN/latest/index.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<a id=\"more\"></a>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<ol>\n<li>如果已安装Anaconda，默认是含<code>requests</code>模块。</li>\n<li>终端命令行安装，<a href=\"http://docs.python-requests.org/zh_CN/latest/user/install.html#install\" target=\"_blank\" rel=\"noopener\">详情</a> <figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip <span class=\"keyword\">install</span> requests</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\">from requests.auth <span class=\"keyword\">import</span> AuthBase</span><br><span class=\"line\"></span><br><span class=\"line\">domain = 'http:<span class=\"comment\">//httpbin.org'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/get'</span>, params=&#123;<span class=\"string\">'aa'</span>: <span class=\"number\">1</span>, <span class=\"string\">'bb'</span>: <span class=\"number\">2</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.status_code, <span class=\"keyword\">res</span>.text)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.url, <span class=\"keyword\">res</span>.json())</span><br></pre></td></tr></table></figure>\n<h4 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.post(domain + <span class=\"string\">'/post'</span>, params=&#123;<span class=\"string\">'aa'</span>: <span class=\"number\">11</span>, <span class=\"string\">'bb'</span>: <span class=\"number\">22</span>&#125;, data=&#123;<span class=\"string\">'username'</span>: <span class=\"string\">'bayuefen'</span>, <span class=\"string\">'password'</span>: <span class=\"string\">'123456'</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.status_code, <span class=\"keyword\">res</span>.text)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.url, <span class=\"keyword\">res</span>.json())</span><br></pre></td></tr></table></figure>\n<h4 id=\"PATCH\"><a href=\"#PATCH\" class=\"headerlink\" title=\"PATCH\"></a>PATCH</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = requests.patch(domain + <span class=\"string\">'/patch'</span>, data=&#123;<span class=\"string\">'username'</span>:<span class=\"string\">'bayuefen'</span>,<span class=\"string\">'password'</span>:<span class=\"string\">'123456'</span>,<span class=\"string\">'visibility'</span>:<span class=\"string\">'private'</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(res.status_code, res.text)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(res.headers)</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"keyword\">delete</span>(domain + <span class=\"string\">'/delete'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.status_code, <span class=\"keyword\">res</span>.text)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.headers)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Session-⭐️⭐️⭐️\"><a href=\"#Session-⭐️⭐️⭐️\" class=\"headerlink\" title=\"Session (⭐️⭐️⭐️)\"></a>Session (⭐️⭐️⭐️)</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rs = requests.Session()</span><br><span class=\"line\">rs.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/cookies/set/username/bayuefen'</span>)</span><br><span class=\"line\"><span class=\"keyword\">res</span> = rs.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/cookies'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.text)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>1.Session对象能够跨请求保持某些特定参数，并且同一个Session实例发出的所有请求之间保持cookie<br>2.对于同一个服务器发送多个请求，底层TCP连接可被重用，有显著的性能提升</p>\n</blockquote>\n<h4 id=\"Cookie-⭐️⭐️⭐️\"><a href=\"#Cookie-⭐️⭐️⭐️\" class=\"headerlink\" title=\"Cookie  (⭐️⭐️⭐️)\"></a>Cookie  (⭐️⭐️⭐️)</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cookies = dict(admin_token=<span class=\"string\">'xxxxxxxxx'</span>)</span><br><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/cookies/set'</span>, cookies=cookies)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.text)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jar = requests<span class=\"selector-class\">.cookies</span><span class=\"selector-class\">.RequestsCookieJar</span>()</span><br><span class=\"line\">jar.set(<span class=\"string\">'bayuefen_cookies'</span>, <span class=\"string\">'123456'</span>, domain=<span class=\"string\">'httpbin.org'</span>, path=<span class=\"string\">'/cookies'</span>)</span><br><span class=\"line\">jar.set(<span class=\"string\">'bayuefen_values'</span>, <span class=\"string\">'my_values'</span>, domain=<span class=\"string\">'httpbin.org'</span>, path=<span class=\"string\">'/elsewhere'</span>)</span><br><span class=\"line\">res1 = requests.get(domain + <span class=\"string\">'/cookies'</span>, cookies=jar)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(res1.text)</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Cookie的返回对象是RequestsCookieJar，这种模式适用于跨域名跨路径使用</p>\n</blockquote>\n<h4 id=\"redirect\"><a href=\"#redirect\" class=\"headerlink\" title=\"redirect\"></a>redirect</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/redirect-to'</span>, params=&#123;<span class=\"string\">'url'</span>:<span class=\"string\">'https://www.baidu.com'</span>, <span class=\"string\">'status_code'</span>:<span class=\"number\">302</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.url, <span class=\"keyword\">res</span>.status_code)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.<span class=\"keyword\">history</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可配置allow_redirects = False 禁用重定向</p>\n</blockquote>\n<h4 id=\"timeout\"><a href=\"#timeout\" class=\"headerlink\" title=\"timeout\"></a>timeout</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/get'</span>, timeout=<span class=\"number\">0.001</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.raise_for_status())</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>超时的异常触发仅仅针对连接过程，与相应体的下载无关，即请求发起至服务器相应的最大时间，超过则以异常处理</p>\n</blockquote>\n<h4 id=\"file-upload\"><a href=\"#file-upload\" class=\"headerlink\" title=\"file upload\"></a>file upload</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">file</span> = &#123;<span class=\"string\">'txtFile'</span>: <span class=\"keyword\">open</span>(<span class=\"string\">'./test.txt'</span>, <span class=\"string\">'rb'</span>)&#125;</span><br><span class=\"line\">upload_data = &#123;<span class=\"string\">\"parentId\"</span>: <span class=\"string\">\"\"</span>, <span class=\"string\">\"fileCategory\"</span>: <span class=\"string\">\"personal\"</span>, <span class=\"string\">\"fileSize\"</span>: <span class=\"number\">179</span>, <span class=\"string\">\"fileName\"</span>: <span class=\"string\">\"test.txt\"</span>, <span class=\"string\">\"uoType\"</span>: <span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">res</span> = requests.post(domain + <span class=\"string\">'/post'</span>, upload_data, <span class=\"keyword\">files</span>=<span class=\"keyword\">file</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.url, <span class=\"keyword\">res</span>.status_code)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.json())</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>超大文件的传输使用multipart/form-data，默认情况下requests是不支持的，需要使用requests-toolbelt</p>\n</blockquote>\n<h4 id=\"file-download\"><a href=\"#file-download\" class=\"headerlink\" title=\"file download\"></a>file download</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/image/jpeg'</span>, stream=True)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.raw, <span class=\"keyword\">res</span>.raw.<span class=\"keyword\">read</span>(<span class=\"number\">10</span>))</span><br><span class=\"line\">with <span class=\"keyword\">open</span>(<span class=\"string\">'./test.jpeg'</span>, <span class=\"string\">'wb'</span>) <span class=\"keyword\">as</span> <span class=\"keyword\">f</span>:</span><br><span class=\"line\">    <span class=\"keyword\">f</span>.<span class=\"keyword\">write</span>(<span class=\"keyword\">res</span>.content)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>notice: 下载原始相应内容（images/xlsx/pdf等），通过设置stream获取raw</p>\n</blockquote>\n<h4 id=\"JSON解码器\"><a href=\"#JSON解码器\" class=\"headerlink\" title=\"JSON解码器\"></a>JSON解码器</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.post(domain + <span class=\"string\">'/post'</span>, data=&#123;<span class=\"string\">'aa'</span>: <span class=\"number\">11</span>, <span class=\"string\">'bb'</span>: <span class=\"number\">2</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.raise_for_status(), <span class=\"keyword\">res</span>.status_code)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">res</span>.json()</span><br><span class=\"line\">except ValueError:</span><br><span class=\"line\">    logging.error(<span class=\"string\">'No JSON object could be decoded'</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>JSON被解码返回成功，不一定代表HTTP相应成功；检查请求响应是否成功，需通过<code>response.raise_for_status()</code> or <code>response.status_code</code>去判别</p>\n</blockquote>\n<h4 id=\"定制-headers\"><a href=\"#定制-headers\" class=\"headerlink\" title=\"定制 headers\"></a>定制 headers</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headers = &#123;</span><br><span class=\"line\">    <span class=\"string\">'user-agent'</span>: <span class=\"string\">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/get'</span>, headers=headers)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.json())</span><br><span class=\"line\"># 响应头</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.headers.<span class=\"built_in\">get</span>(<span class=\"string\">'content-type'</span>))</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>定制headers低于特定场景的信息源</p>\n<ol>\n<li>如果在 .netrc 中设置了用户认证信息，使用 headers= 设置的授权就不会生效。而如果设置了 auth= 参数，<code>.netrc</code> 的设置就无效了。</li>\n<li>如果被重定向到别的主机，授权 header 就会被删除。</li>\n<li>代理授权 header 会被 URL 中提供的代理身份覆盖掉。</li>\n<li>在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。</li>\n</ol>\n</blockquote>\n<h4 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h4><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requests.get(<span class=\"symbol\">'https</span>://github.com', verify=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"流式请求\"><a href=\"#流式请求\" class=\"headerlink\" title=\"流式请求\"></a>流式请求</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/stream/20'</span>, stream=True)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.raw)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">res</span>.encoding <span class=\"keyword\">is</span> None:</span><br><span class=\"line\">    <span class=\"keyword\">res</span>.encoding = <span class=\"string\">'utf-8'</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">line</span> in <span class=\"keyword\">res</span>.iter_lines():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">line</span>:</span><br><span class=\"line\">        decoded_line = <span class=\"built_in\">line</span>.decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">print</span>(json.loads(decoded_line))</span><br></pre></td></tr></table></figure>\n<h4 id=\"Auth-HTTP基本身份认证\"><a href=\"#Auth-HTTP基本身份认证\" class=\"headerlink\" title=\"Auth HTTP基本身份认证\"></a>Auth HTTP基本身份认证</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auth = requests<span class=\"selector-class\">.auth</span><span class=\"selector-class\">.HTTPBasicAuth</span>(<span class=\"string\">'user'</span>, <span class=\"string\">'passwd'</span>)</span><br><span class=\"line\">res = requests.get(domain + <span class=\"string\">'/hidden-basic-auth/user/passwd'</span>, auth=auth)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(res.json()</span></span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>1.<a href=\"http://docs.python-requests.org/zh_CN/latest/index.html#\" target=\"_blank\" rel=\"noopener\">Requests: 让 HTTP 服务人类</a><br>2.<a href=\"http://httpbin.org/\" target=\"_blank\" rel=\"noopener\">httpbin</a><br>3.<a href=\"https://github.com/bayuefen/demos/blob/master/requestDemo/test.py\" target=\"_blank\" rel=\"noopener\">code</a></p>\n","site":{"data":{}},"excerpt":"<p>本文基于<code>python3.7</code>及第三方模块<code>requests</code>编写入门级简易模式的HTTP请求应用于详解。<br><code>requests</code>是由python编写,基于urllib, 采用Apache2 Licensed开源协议的HTTP三方模块。详情应用见<a href=\"http://docs.python-requests.org/zh_CN/latest/index.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<ol>\n<li>如果已安装Anaconda，默认是含<code>requests</code>模块。</li>\n<li>终端命令行安装，<a href=\"http://docs.python-requests.org/zh_CN/latest/user/install.html#install\" target=\"_blank\" rel=\"noopener\">详情</a> <figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip <span class=\"keyword\">install</span> requests</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\">from requests.auth <span class=\"keyword\">import</span> AuthBase</span><br><span class=\"line\"></span><br><span class=\"line\">domain = 'http:<span class=\"comment\">//httpbin.org'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/get'</span>, params=&#123;<span class=\"string\">'aa'</span>: <span class=\"number\">1</span>, <span class=\"string\">'bb'</span>: <span class=\"number\">2</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.status_code, <span class=\"keyword\">res</span>.text)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.url, <span class=\"keyword\">res</span>.json())</span><br></pre></td></tr></table></figure>\n<h4 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.post(domain + <span class=\"string\">'/post'</span>, params=&#123;<span class=\"string\">'aa'</span>: <span class=\"number\">11</span>, <span class=\"string\">'bb'</span>: <span class=\"number\">22</span>&#125;, data=&#123;<span class=\"string\">'username'</span>: <span class=\"string\">'bayuefen'</span>, <span class=\"string\">'password'</span>: <span class=\"string\">'123456'</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.status_code, <span class=\"keyword\">res</span>.text)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.url, <span class=\"keyword\">res</span>.json())</span><br></pre></td></tr></table></figure>\n<h4 id=\"PATCH\"><a href=\"#PATCH\" class=\"headerlink\" title=\"PATCH\"></a>PATCH</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = requests.patch(domain + <span class=\"string\">'/patch'</span>, data=&#123;<span class=\"string\">'username'</span>:<span class=\"string\">'bayuefen'</span>,<span class=\"string\">'password'</span>:<span class=\"string\">'123456'</span>,<span class=\"string\">'visibility'</span>:<span class=\"string\">'private'</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(res.status_code, res.text)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(res.headers)</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"keyword\">delete</span>(domain + <span class=\"string\">'/delete'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.status_code, <span class=\"keyword\">res</span>.text)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.headers)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Session-⭐️⭐️⭐️\"><a href=\"#Session-⭐️⭐️⭐️\" class=\"headerlink\" title=\"Session (⭐️⭐️⭐️)\"></a>Session (⭐️⭐️⭐️)</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rs = requests.Session()</span><br><span class=\"line\">rs.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/cookies/set/username/bayuefen'</span>)</span><br><span class=\"line\"><span class=\"keyword\">res</span> = rs.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/cookies'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.text)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>1.Session对象能够跨请求保持某些特定参数，并且同一个Session实例发出的所有请求之间保持cookie<br>2.对于同一个服务器发送多个请求，底层TCP连接可被重用，有显著的性能提升</p>\n</blockquote>\n<h4 id=\"Cookie-⭐️⭐️⭐️\"><a href=\"#Cookie-⭐️⭐️⭐️\" class=\"headerlink\" title=\"Cookie  (⭐️⭐️⭐️)\"></a>Cookie  (⭐️⭐️⭐️)</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cookies = dict(admin_token=<span class=\"string\">'xxxxxxxxx'</span>)</span><br><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/cookies/set'</span>, cookies=cookies)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.text)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jar = requests<span class=\"selector-class\">.cookies</span><span class=\"selector-class\">.RequestsCookieJar</span>()</span><br><span class=\"line\">jar.set(<span class=\"string\">'bayuefen_cookies'</span>, <span class=\"string\">'123456'</span>, domain=<span class=\"string\">'httpbin.org'</span>, path=<span class=\"string\">'/cookies'</span>)</span><br><span class=\"line\">jar.set(<span class=\"string\">'bayuefen_values'</span>, <span class=\"string\">'my_values'</span>, domain=<span class=\"string\">'httpbin.org'</span>, path=<span class=\"string\">'/elsewhere'</span>)</span><br><span class=\"line\">res1 = requests.get(domain + <span class=\"string\">'/cookies'</span>, cookies=jar)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(res1.text)</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Cookie的返回对象是RequestsCookieJar，这种模式适用于跨域名跨路径使用</p>\n</blockquote>\n<h4 id=\"redirect\"><a href=\"#redirect\" class=\"headerlink\" title=\"redirect\"></a>redirect</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/redirect-to'</span>, params=&#123;<span class=\"string\">'url'</span>:<span class=\"string\">'https://www.baidu.com'</span>, <span class=\"string\">'status_code'</span>:<span class=\"number\">302</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.url, <span class=\"keyword\">res</span>.status_code)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.<span class=\"keyword\">history</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可配置allow_redirects = False 禁用重定向</p>\n</blockquote>\n<h4 id=\"timeout\"><a href=\"#timeout\" class=\"headerlink\" title=\"timeout\"></a>timeout</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/get'</span>, timeout=<span class=\"number\">0.001</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.raise_for_status())</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>超时的异常触发仅仅针对连接过程，与相应体的下载无关，即请求发起至服务器相应的最大时间，超过则以异常处理</p>\n</blockquote>\n<h4 id=\"file-upload\"><a href=\"#file-upload\" class=\"headerlink\" title=\"file upload\"></a>file upload</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">file</span> = &#123;<span class=\"string\">'txtFile'</span>: <span class=\"keyword\">open</span>(<span class=\"string\">'./test.txt'</span>, <span class=\"string\">'rb'</span>)&#125;</span><br><span class=\"line\">upload_data = &#123;<span class=\"string\">\"parentId\"</span>: <span class=\"string\">\"\"</span>, <span class=\"string\">\"fileCategory\"</span>: <span class=\"string\">\"personal\"</span>, <span class=\"string\">\"fileSize\"</span>: <span class=\"number\">179</span>, <span class=\"string\">\"fileName\"</span>: <span class=\"string\">\"test.txt\"</span>, <span class=\"string\">\"uoType\"</span>: <span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">res</span> = requests.post(domain + <span class=\"string\">'/post'</span>, upload_data, <span class=\"keyword\">files</span>=<span class=\"keyword\">file</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.url, <span class=\"keyword\">res</span>.status_code)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.json())</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>超大文件的传输使用multipart/form-data，默认情况下requests是不支持的，需要使用requests-toolbelt</p>\n</blockquote>\n<h4 id=\"file-download\"><a href=\"#file-download\" class=\"headerlink\" title=\"file download\"></a>file download</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/image/jpeg'</span>, stream=True)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.raw, <span class=\"keyword\">res</span>.raw.<span class=\"keyword\">read</span>(<span class=\"number\">10</span>))</span><br><span class=\"line\">with <span class=\"keyword\">open</span>(<span class=\"string\">'./test.jpeg'</span>, <span class=\"string\">'wb'</span>) <span class=\"keyword\">as</span> <span class=\"keyword\">f</span>:</span><br><span class=\"line\">    <span class=\"keyword\">f</span>.<span class=\"keyword\">write</span>(<span class=\"keyword\">res</span>.content)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>notice: 下载原始相应内容（images/xlsx/pdf等），通过设置stream获取raw</p>\n</blockquote>\n<h4 id=\"JSON解码器\"><a href=\"#JSON解码器\" class=\"headerlink\" title=\"JSON解码器\"></a>JSON解码器</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.post(domain + <span class=\"string\">'/post'</span>, data=&#123;<span class=\"string\">'aa'</span>: <span class=\"number\">11</span>, <span class=\"string\">'bb'</span>: <span class=\"number\">2</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.raise_for_status(), <span class=\"keyword\">res</span>.status_code)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">res</span>.json()</span><br><span class=\"line\">except ValueError:</span><br><span class=\"line\">    logging.error(<span class=\"string\">'No JSON object could be decoded'</span>)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>JSON被解码返回成功，不一定代表HTTP相应成功；检查请求响应是否成功，需通过<code>response.raise_for_status()</code> or <code>response.status_code</code>去判别</p>\n</blockquote>\n<h4 id=\"定制-headers\"><a href=\"#定制-headers\" class=\"headerlink\" title=\"定制 headers\"></a>定制 headers</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headers = &#123;</span><br><span class=\"line\">    <span class=\"string\">'user-agent'</span>: <span class=\"string\">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/get'</span>, headers=headers)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.json())</span><br><span class=\"line\"># 响应头</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.headers.<span class=\"built_in\">get</span>(<span class=\"string\">'content-type'</span>))</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>定制headers低于特定场景的信息源</p>\n<ol>\n<li>如果在 .netrc 中设置了用户认证信息，使用 headers= 设置的授权就不会生效。而如果设置了 auth= 参数，<code>.netrc</code> 的设置就无效了。</li>\n<li>如果被重定向到别的主机，授权 header 就会被删除。</li>\n<li>代理授权 header 会被 URL 中提供的代理身份覆盖掉。</li>\n<li>在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。</li>\n</ol>\n</blockquote>\n<h4 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h4><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requests.get(<span class=\"symbol\">'https</span>://github.com', verify=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"流式请求\"><a href=\"#流式请求\" class=\"headerlink\" title=\"流式请求\"></a>流式请求</h4><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">res</span> = requests.<span class=\"built_in\">get</span>(domain + <span class=\"string\">'/stream/20'</span>, stream=True)</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"keyword\">res</span>.raw)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">res</span>.encoding <span class=\"keyword\">is</span> None:</span><br><span class=\"line\">    <span class=\"keyword\">res</span>.encoding = <span class=\"string\">'utf-8'</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">line</span> in <span class=\"keyword\">res</span>.iter_lines():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">line</span>:</span><br><span class=\"line\">        decoded_line = <span class=\"built_in\">line</span>.decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">print</span>(json.loads(decoded_line))</span><br></pre></td></tr></table></figure>\n<h4 id=\"Auth-HTTP基本身份认证\"><a href=\"#Auth-HTTP基本身份认证\" class=\"headerlink\" title=\"Auth HTTP基本身份认证\"></a>Auth HTTP基本身份认证</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auth = requests<span class=\"selector-class\">.auth</span><span class=\"selector-class\">.HTTPBasicAuth</span>(<span class=\"string\">'user'</span>, <span class=\"string\">'passwd'</span>)</span><br><span class=\"line\">res = requests.get(domain + <span class=\"string\">'/hidden-basic-auth/user/passwd'</span>, auth=auth)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(res.json()</span></span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>1.<a href=\"http://docs.python-requests.org/zh_CN/latest/index.html#\" target=\"_blank\" rel=\"noopener\">Requests: 让 HTTP 服务人类</a><br>2.<a href=\"http://httpbin.org/\" target=\"_blank\" rel=\"noopener\">httpbin</a><br>3.<a href=\"https://github.com/bayuefen/demos/blob/master/requestDemo/test.py\" target=\"_blank\" rel=\"noopener\">code</a></p>"},{"title":"基于Node及MongoDB的服务配置与部署","date":"2019-04-19T02:52:36.000Z","_content":"在过去几天的调研参考之后，拟定*Fork*Github相关的repositories，构建整站解决方案。\n- 后端服务基于[node-elm](https://github.com/bayuefen/node-elm)\n- 数据库采用[MongoDB](https://www.mongodb.com/)\n- 商户系统Web服务基于[vue2-manage](https://github.com/bayuefen/vue2-manage)\n- 用户系统Web服务基于[vue2-elm](https://github.com/bayuefen/vue2-elm)\n\n本文主要根据Node及MongoDB，在服务配置与部署过程中所遇到的一些问题的解决方案进行总结。\n\n<!-- more -->\n\n### Node Server install\n#### 安装依赖\n1、node (6.0 及以上版本)\n2、mongodb (开启状态)\n3、GraphicsMagick (裁切图片)\n4、yarn/npm(Node packages管理)\n5、pm2(守护进程)\n\n####  项目运行\n````\ngit clone https://github.com/bayuefen/node-elm  \n\ncd node-elm\n\nyarn install / npm install\n\nyarn run dev\n\n````\n访问: `http://localhost:8001`（如果已启动前台程序，则不需打开此地址）\n本人将`node-elm`工程项目clone至阿里云ECS上，安装好上述环境依赖及node packages后，使用pm2守护进程\n````\npm2 start 'yarn run dev'\n````\n\n\n###  MongoDB Community Edition install(.rpm Packages)\n#### 安装流程\n1、创建`/etc/yum.repos.d/mongodb-org-4.2.repo`文件;\n2、写入`yum`安装配置信息\n````\n[mongodb-org-4.2]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.1/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc\n````\n3、安装MongoDB packages\n````\nsudo yum install -y mongodb-org-unstable    \n````\n4、!特定版本packages及组件安装\n````\nsudo yum install -y mongodb-org-unstable-4.1.10 mongodb-org-unstable-server-4.1.10 mongodb-org-unstable-shell-4.1.10 mongodb-org-unstable-mongos-4.1.10 mongodb-org-unstable-tools-4.1.10\n````\n\n#### 启用流程\n\n1、MongoDB默认文件创建\n- /var/lib/mongo (the data directory)\n- /var/log/mongodb (the log directory)\n\n2、启用MongoDB\n````\nsudo service mongod start\n````\n\n3、验证启用是否成功\n`27017`是默认端口，可以在`/etc/mongod.conf`中更改。\n````\nsudo chkconfig mongod on\n````\n4、关闭MongoDB\n````\nsudo service mongod stop\n````\n5、重启MongoDB\n````\nsudo service mongod restart\n````\n6、MongoDB使用\n````\nmongo\n````\n\n#### MongoDB权限配置\n默认安装的MongoDB是不具备权限验证的，因为需要通过Navicat访问远程ECS上的DB服务，为了安全起见，给MongoDB配置相应的权限验证机制是非常必要的。\n##### 超级管理员创建\n````\n# 启用mongoDB后使用\nmongo\n\n# 切换至超级管理员模式\nuse admin\n\n# 创建超级管理员\ndb.createUser({user:'userName', pwd:'password', roles:['userAdminAnyDatabase']})\n\n````\nrole类型:\n- readAnyDatabase 任何数据库的只读权限(和read相似)\n- readWriteAnyDatabase 任何数据库的读写权限(和readWrite相似)\n- userAdminAnyDatabase 任何数据库用户的管理权限(和userAdmin相似)\n- dbAdminAnyDatabase 任何数据库的管理权限(dbAdmin相似)\n\n##### 创建用户\n````\n# 进入超级管理员模式并验证\nuse admin\n\ndb.auth('userName','password')\n\n# 查看数据库\nshow dbs\n\n# 进入到elm数据库\nshow elm\n\n# 创建elm数据库用户\ndb.createUser({user:'user-bayuefen',pwd:'password',roles:[{role:'readWrite',db:'elm'}]})\n````\n以上步骤核心完成超级管理员的创建验证及单个数据库的用户创建。\n具备了以上的权限配置，我们即可通过navicat进行数据库的查看与管理；同时，在`Node`服务中我们可以使用`mongoose` package对数据库进行CURD\n###### Node\n````\nimport mongoose from 'mongoose';\nmongoose.connect('mongodb://user:pwd@localhost:27017/elm', {useMongoClient:true});\n````\n###### Navicat\n````\nserver: ECS ip\nport: 27017 (default)\nuser: user\npwd: password\ndb: db_name\n````\nps:ECS需要通过阿里云后台服务打开安全策略中的27017端口的外网访问权限\n\n#### 问题记录\nQ:MongoDB在配置权限之后，重启Mongo,无法启动服务。抛`Unit mongod.service entered failed state.`异常\nA:排查后，发现Centos需要将MongoDB添加至`systemd`中，否则会出现问题。[Issues](https://github.com/jingxinxin/tiankeng/issues/5)\n添加`systemd`\n````\nvim /usr/lib/systemd/system/mongod.service\n\n````\n> [Unit]\n> Description=mongodb database\n>  \n> [Service]\n> User=mongod\n> Group=mongod\n> Environment=\"OPTIONS=--quiet -f /etc/mongod.conf\"\n> ExecStart=/usr/bin/mongod $OPTIONS run\n> PIDFile=/var/run/mongodb/mongod.pid\n> \n> [Install]\n> WantedBy=multi-user.target\n\n创建链接：\n````\nln -s /usr/lib/systemd/system/mongod.service /etc/systemd/system/multi-user.target.wants/\n````\n\n重新加载systemctl\n````\nsystemctl daemon-reload\n````\n#### 参考文档\n- [Centos7](https://docs.mongodb.com/master/tutorial/install-mongodb-on-red-hat/#to-use-non-default-directories)\n- [macOS](https://docs.mongodb.com/master/tutorial/install-mongodb-on-os-x/)\n- [Windows](https://docs.mongodb.com/master/tutorial/install-mongodb-on-windows/)\n\n\n\n","source":"_posts/node-server-deploy.md","raw":"---\ntitle: 基于Node及MongoDB的服务配置与部署\ndate: 2019-04-19 10:52:36\ntags:\n    - Node\n    - MongoDB\n    - 服务部署\n    - 日记\n---\n在过去几天的调研参考之后，拟定*Fork*Github相关的repositories，构建整站解决方案。\n- 后端服务基于[node-elm](https://github.com/bayuefen/node-elm)\n- 数据库采用[MongoDB](https://www.mongodb.com/)\n- 商户系统Web服务基于[vue2-manage](https://github.com/bayuefen/vue2-manage)\n- 用户系统Web服务基于[vue2-elm](https://github.com/bayuefen/vue2-elm)\n\n本文主要根据Node及MongoDB，在服务配置与部署过程中所遇到的一些问题的解决方案进行总结。\n\n<!-- more -->\n\n### Node Server install\n#### 安装依赖\n1、node (6.0 及以上版本)\n2、mongodb (开启状态)\n3、GraphicsMagick (裁切图片)\n4、yarn/npm(Node packages管理)\n5、pm2(守护进程)\n\n####  项目运行\n````\ngit clone https://github.com/bayuefen/node-elm  \n\ncd node-elm\n\nyarn install / npm install\n\nyarn run dev\n\n````\n访问: `http://localhost:8001`（如果已启动前台程序，则不需打开此地址）\n本人将`node-elm`工程项目clone至阿里云ECS上，安装好上述环境依赖及node packages后，使用pm2守护进程\n````\npm2 start 'yarn run dev'\n````\n\n\n###  MongoDB Community Edition install(.rpm Packages)\n#### 安装流程\n1、创建`/etc/yum.repos.d/mongodb-org-4.2.repo`文件;\n2、写入`yum`安装配置信息\n````\n[mongodb-org-4.2]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.1/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc\n````\n3、安装MongoDB packages\n````\nsudo yum install -y mongodb-org-unstable    \n````\n4、!特定版本packages及组件安装\n````\nsudo yum install -y mongodb-org-unstable-4.1.10 mongodb-org-unstable-server-4.1.10 mongodb-org-unstable-shell-4.1.10 mongodb-org-unstable-mongos-4.1.10 mongodb-org-unstable-tools-4.1.10\n````\n\n#### 启用流程\n\n1、MongoDB默认文件创建\n- /var/lib/mongo (the data directory)\n- /var/log/mongodb (the log directory)\n\n2、启用MongoDB\n````\nsudo service mongod start\n````\n\n3、验证启用是否成功\n`27017`是默认端口，可以在`/etc/mongod.conf`中更改。\n````\nsudo chkconfig mongod on\n````\n4、关闭MongoDB\n````\nsudo service mongod stop\n````\n5、重启MongoDB\n````\nsudo service mongod restart\n````\n6、MongoDB使用\n````\nmongo\n````\n\n#### MongoDB权限配置\n默认安装的MongoDB是不具备权限验证的，因为需要通过Navicat访问远程ECS上的DB服务，为了安全起见，给MongoDB配置相应的权限验证机制是非常必要的。\n##### 超级管理员创建\n````\n# 启用mongoDB后使用\nmongo\n\n# 切换至超级管理员模式\nuse admin\n\n# 创建超级管理员\ndb.createUser({user:'userName', pwd:'password', roles:['userAdminAnyDatabase']})\n\n````\nrole类型:\n- readAnyDatabase 任何数据库的只读权限(和read相似)\n- readWriteAnyDatabase 任何数据库的读写权限(和readWrite相似)\n- userAdminAnyDatabase 任何数据库用户的管理权限(和userAdmin相似)\n- dbAdminAnyDatabase 任何数据库的管理权限(dbAdmin相似)\n\n##### 创建用户\n````\n# 进入超级管理员模式并验证\nuse admin\n\ndb.auth('userName','password')\n\n# 查看数据库\nshow dbs\n\n# 进入到elm数据库\nshow elm\n\n# 创建elm数据库用户\ndb.createUser({user:'user-bayuefen',pwd:'password',roles:[{role:'readWrite',db:'elm'}]})\n````\n以上步骤核心完成超级管理员的创建验证及单个数据库的用户创建。\n具备了以上的权限配置，我们即可通过navicat进行数据库的查看与管理；同时，在`Node`服务中我们可以使用`mongoose` package对数据库进行CURD\n###### Node\n````\nimport mongoose from 'mongoose';\nmongoose.connect('mongodb://user:pwd@localhost:27017/elm', {useMongoClient:true});\n````\n###### Navicat\n````\nserver: ECS ip\nport: 27017 (default)\nuser: user\npwd: password\ndb: db_name\n````\nps:ECS需要通过阿里云后台服务打开安全策略中的27017端口的外网访问权限\n\n#### 问题记录\nQ:MongoDB在配置权限之后，重启Mongo,无法启动服务。抛`Unit mongod.service entered failed state.`异常\nA:排查后，发现Centos需要将MongoDB添加至`systemd`中，否则会出现问题。[Issues](https://github.com/jingxinxin/tiankeng/issues/5)\n添加`systemd`\n````\nvim /usr/lib/systemd/system/mongod.service\n\n````\n> [Unit]\n> Description=mongodb database\n>  \n> [Service]\n> User=mongod\n> Group=mongod\n> Environment=\"OPTIONS=--quiet -f /etc/mongod.conf\"\n> ExecStart=/usr/bin/mongod $OPTIONS run\n> PIDFile=/var/run/mongodb/mongod.pid\n> \n> [Install]\n> WantedBy=multi-user.target\n\n创建链接：\n````\nln -s /usr/lib/systemd/system/mongod.service /etc/systemd/system/multi-user.target.wants/\n````\n\n重新加载systemctl\n````\nsystemctl daemon-reload\n````\n#### 参考文档\n- [Centos7](https://docs.mongodb.com/master/tutorial/install-mongodb-on-red-hat/#to-use-non-default-directories)\n- [macOS](https://docs.mongodb.com/master/tutorial/install-mongodb-on-os-x/)\n- [Windows](https://docs.mongodb.com/master/tutorial/install-mongodb-on-windows/)\n\n\n\n","slug":"node-server-deploy","published":1,"updated":"2019-04-21T15:30:24.000Z","_id":"cjur15bax00052o1ao8b80ujd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在过去几天的调研参考之后，拟定<em>Fork</em>Github相关的repositories，构建整站解决方案。</p>\n<ul>\n<li>后端服务基于<a href=\"https://github.com/bayuefen/node-elm\" target=\"_blank\" rel=\"noopener\">node-elm</a></li>\n<li>数据库采用<a href=\"https://www.mongodb.com/\" target=\"_blank\" rel=\"noopener\">MongoDB</a></li>\n<li>商户系统Web服务基于<a href=\"https://github.com/bayuefen/vue2-manage\" target=\"_blank\" rel=\"noopener\">vue2-manage</a></li>\n<li>用户系统Web服务基于<a href=\"https://github.com/bayuefen/vue2-elm\" target=\"_blank\" rel=\"noopener\">vue2-elm</a></li>\n</ul>\n<p>本文主要根据Node及MongoDB，在服务配置与部署过程中所遇到的一些问题的解决方案进行总结。</p>\n<a id=\"more\"></a>\n<h3 id=\"Node-Server-install\"><a href=\"#Node-Server-install\" class=\"headerlink\" title=\"Node Server install\"></a>Node Server install</h3><h4 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h4><p>1、node (6.0 及以上版本)<br>2、mongodb (开启状态)<br>3、GraphicsMagick (裁切图片)<br>4、yarn/npm(Node packages管理)<br>5、pm2(守护进程)</p>\n<h4 id=\"项目运行\"><a href=\"#项目运行\" class=\"headerlink\" title=\"项目运行\"></a>项目运行</h4><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">clone</span> <span class=\"title\">https</span>://github.com/bayuefen/<span class=\"keyword\">node</span><span class=\"title\">-elm</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">cd <span class=\"keyword\">node</span><span class=\"title\">-elm</span></span><br><span class=\"line\"></span><br><span class=\"line\">yarn install / npm install</span><br><span class=\"line\"></span><br><span class=\"line\">yarn run dev</span><br></pre></td></tr></table></figure>\n<p>访问: <code>http://localhost:8001</code>（如果已启动前台程序，则不需打开此地址）<br>本人将<code>node-elm</code>工程项目clone至阿里云ECS上，安装好上述环境依赖及node packages后，使用pm2守护进程<br><figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p<span class=\"name\">m2</span> start <span class=\"string\">'yarn run dev'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"MongoDB-Community-Edition-install-rpm-Packages\"><a href=\"#MongoDB-Community-Edition-install-rpm-Packages\" class=\"headerlink\" title=\"MongoDB Community Edition install(.rpm Packages)\"></a>MongoDB Community Edition install(.rpm Packages)</h3><h4 id=\"安装流程\"><a href=\"#安装流程\" class=\"headerlink\" title=\"安装流程\"></a>安装流程</h4><p>1、创建<code>/etc/yum.repos.d/mongodb-org-4.2.repo</code>文件;<br>2、写入<code>yum</code>安装配置信息<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[mongodb-org-4.2]</span></span><br><span class=\"line\"><span class=\"attr\">name</span>=MongoDB Repository</span><br><span class=\"line\"><span class=\"attr\">baseurl</span>=https://repo.mongodb.org/yum/redhat/<span class=\"variable\">$releasever</span>/mongodb-org/<span class=\"number\">4.1</span>/x<span class=\"number\">86_64</span>/</span><br><span class=\"line\"><span class=\"attr\">gpgcheck</span>=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">enabled</span>=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">gpgkey</span>=https://www.mongodb.org/static/pgp/server-<span class=\"number\">4.2</span>.asc</span><br></pre></td></tr></table></figure></p>\n<p>3、安装MongoDB packages<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum <span class=\"keyword\">install</span> -y mongodb-org-unstable</span><br></pre></td></tr></table></figure></p>\n<p>4、!特定版本packages及组件安装<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">-y</span> <span class=\"selector-tag\">mongodb-org-unstable-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span> <span class=\"selector-tag\">mongodb-org-unstable-server-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span> <span class=\"selector-tag\">mongodb-org-unstable-shell-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span> <span class=\"selector-tag\">mongodb-org-unstable-mongos-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span> <span class=\"selector-tag\">mongodb-org-unstable-tools-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"启用流程\"><a href=\"#启用流程\" class=\"headerlink\" title=\"启用流程\"></a>启用流程</h4><p>1、MongoDB默认文件创建</p>\n<ul>\n<li>/var/lib/mongo (the data directory)</li>\n<li>/var/log/mongodb (the log directory)</li>\n</ul>\n<p>2、启用MongoDB<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo<span class=\"built_in\"> service </span>mongod start</span><br></pre></td></tr></table></figure></p>\n<p>3、验证启用是否成功<br><code>27017</code>是默认端口，可以在<code>/etc/mongod.conf</code>中更改。<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chkconfig mongod <span class=\"keyword\">on</span></span><br></pre></td></tr></table></figure></p>\n<p>4、关闭MongoDB<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo<span class=\"built_in\"> service </span>mongod stop</span><br></pre></td></tr></table></figure></p>\n<p>5、重启MongoDB<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo<span class=\"built_in\"> service </span>mongod restart</span><br></pre></td></tr></table></figure></p>\n<p>6、MongoDB使用<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">mongo</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"MongoDB权限配置\"><a href=\"#MongoDB权限配置\" class=\"headerlink\" title=\"MongoDB权限配置\"></a>MongoDB权限配置</h4><p>默认安装的MongoDB是不具备权限验证的，因为需要通过Navicat访问远程ECS上的DB服务，为了安全起见，给MongoDB配置相应的权限验证机制是非常必要的。</p>\n<h5 id=\"超级管理员创建\"><a href=\"#超级管理员创建\" class=\"headerlink\" title=\"超级管理员创建\"></a>超级管理员创建</h5><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用mongoDB后使用</span></span><br><span class=\"line\">mongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换至超级管理员模式</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"keyword\">admin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建超级管理员</span></span><br><span class=\"line\">db.createUser(&#123;<span class=\"keyword\">user</span>:<span class=\"string\">'userName'</span>, pwd:<span class=\"string\">'password'</span>, <span class=\"keyword\">roles</span>:[<span class=\"string\">'userAdminAnyDatabase'</span>]&#125;)</span><br></pre></td></tr></table></figure>\n<p>role类型:</p>\n<ul>\n<li>readAnyDatabase 任何数据库的只读权限(和read相似)</li>\n<li>readWriteAnyDatabase 任何数据库的读写权限(和readWrite相似)</li>\n<li>userAdminAnyDatabase 任何数据库用户的管理权限(和userAdmin相似)</li>\n<li>dbAdminAnyDatabase 任何数据库的管理权限(dbAdmin相似)</li>\n</ul>\n<h5 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h5><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入超级管理员模式并验证</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"keyword\">admin</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.auth(<span class=\"string\">'userName'</span>,<span class=\"string\">'password'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看数据库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> dbs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入到elm数据库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> elm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建elm数据库用户</span></span><br><span class=\"line\">db.createUser(&#123;<span class=\"keyword\">user</span>:<span class=\"string\">'user-bayuefen'</span>,pwd:<span class=\"string\">'password'</span>,<span class=\"keyword\">roles</span>:[&#123;<span class=\"keyword\">role</span>:<span class=\"string\">'readWrite'</span>,db:<span class=\"string\">'elm'</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure>\n<p>以上步骤核心完成超级管理员的创建验证及单个数据库的用户创建。<br>具备了以上的权限配置，我们即可通过navicat进行数据库的查看与管理；同时，在<code>Node</code>服务中我们可以使用<code>mongoose</code> package对数据库进行CURD</p>\n<h6 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h6><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mongoose <span class=\"keyword\">from</span> <span class=\"string\">'mongoose'</span>;</span><br><span class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://user:pwd@localhost:27017/elm'</span>, &#123;useMongoClient:<span class=\"literal\">true</span>&#125;);</span><br></pre></td></tr></table></figure>\n<h6 id=\"Navicat\"><a href=\"#Navicat\" class=\"headerlink\" title=\"Navicat\"></a>Navicat</h6><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server: ECS ip</span><br><span class=\"line\">port: 27017 (default)</span><br><span class=\"line\">user: user</span><br><span class=\"line\">pwd: password</span><br><span class=\"line\">db: db_name</span><br></pre></td></tr></table></figure>\n<p>ps:ECS需要通过阿里云后台服务打开安全策略中的27017端口的外网访问权限</p>\n<h4 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h4><p>Q:MongoDB在配置权限之后，重启Mongo,无法启动服务。抛<code>Unit mongod.service entered failed state.</code>异常<br>A:排查后，发现Centos需要将MongoDB添加至<code>systemd</code>中，否则会出现问题。<a href=\"https://github.com/jingxinxin/tiankeng/issues/5\" target=\"_blank\" rel=\"noopener\">Issues</a><br>添加<code>systemd</code><br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /usr/<span class=\"class\"><span class=\"keyword\">lib</span>/<span class=\"title\">systemd</span>/<span class=\"title\">system</span>/<span class=\"title\">mongod</span>.<span class=\"title\">service</span></span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>[Unit]<br>Description=mongodb database</p>\n<p>[Service]<br>User=mongod<br>Group=mongod<br>Environment=”OPTIONS=–quiet -f /etc/mongod.conf”<br>ExecStart=/usr/bin/mongod $OPTIONS run<br>PIDFile=/var/run/mongodb/mongod.pid</p>\n<p>[Install]<br>WantedBy=multi-user.target</p>\n</blockquote>\n<p>创建链接：<br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /usr/<span class=\"class\"><span class=\"keyword\">lib</span>/<span class=\"title\">systemd</span>/<span class=\"title\">system</span>/<span class=\"title\">mongod</span>.<span class=\"title\">service</span> /<span class=\"title\">etc</span>/<span class=\"title\">systemd</span>/<span class=\"title\">system</span>/<span class=\"title\">multi</span>-<span class=\"title\">user</span>.<span class=\"title\">target</span>.<span class=\"title\">wants</span>/</span></span><br></pre></td></tr></table></figure></p>\n<p>重新加载systemctl<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">systemctl daemon-reload</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><ul>\n<li><a href=\"https://docs.mongodb.com/master/tutorial/install-mongodb-on-red-hat/#to-use-non-default-directories\" target=\"_blank\" rel=\"noopener\">Centos7</a></li>\n<li><a href=\"https://docs.mongodb.com/master/tutorial/install-mongodb-on-os-x/\" target=\"_blank\" rel=\"noopener\">macOS</a></li>\n<li><a href=\"https://docs.mongodb.com/master/tutorial/install-mongodb-on-windows/\" target=\"_blank\" rel=\"noopener\">Windows</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在过去几天的调研参考之后，拟定<em>Fork</em>Github相关的repositories，构建整站解决方案。</p>\n<ul>\n<li>后端服务基于<a href=\"https://github.com/bayuefen/node-elm\" target=\"_blank\" rel=\"noopener\">node-elm</a></li>\n<li>数据库采用<a href=\"https://www.mongodb.com/\" target=\"_blank\" rel=\"noopener\">MongoDB</a></li>\n<li>商户系统Web服务基于<a href=\"https://github.com/bayuefen/vue2-manage\" target=\"_blank\" rel=\"noopener\">vue2-manage</a></li>\n<li>用户系统Web服务基于<a href=\"https://github.com/bayuefen/vue2-elm\" target=\"_blank\" rel=\"noopener\">vue2-elm</a></li>\n</ul>\n<p>本文主要根据Node及MongoDB，在服务配置与部署过程中所遇到的一些问题的解决方案进行总结。</p>","more":"<h3 id=\"Node-Server-install\"><a href=\"#Node-Server-install\" class=\"headerlink\" title=\"Node Server install\"></a>Node Server install</h3><h4 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h4><p>1、node (6.0 及以上版本)<br>2、mongodb (开启状态)<br>3、GraphicsMagick (裁切图片)<br>4、yarn/npm(Node packages管理)<br>5、pm2(守护进程)</p>\n<h4 id=\"项目运行\"><a href=\"#项目运行\" class=\"headerlink\" title=\"项目运行\"></a>项目运行</h4><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">clone</span> <span class=\"title\">https</span>://github.com/bayuefen/<span class=\"keyword\">node</span><span class=\"title\">-elm</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">cd <span class=\"keyword\">node</span><span class=\"title\">-elm</span></span><br><span class=\"line\"></span><br><span class=\"line\">yarn install / npm install</span><br><span class=\"line\"></span><br><span class=\"line\">yarn run dev</span><br></pre></td></tr></table></figure>\n<p>访问: <code>http://localhost:8001</code>（如果已启动前台程序，则不需打开此地址）<br>本人将<code>node-elm</code>工程项目clone至阿里云ECS上，安装好上述环境依赖及node packages后，使用pm2守护进程<br><figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p<span class=\"name\">m2</span> start <span class=\"string\">'yarn run dev'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"MongoDB-Community-Edition-install-rpm-Packages\"><a href=\"#MongoDB-Community-Edition-install-rpm-Packages\" class=\"headerlink\" title=\"MongoDB Community Edition install(.rpm Packages)\"></a>MongoDB Community Edition install(.rpm Packages)</h3><h4 id=\"安装流程\"><a href=\"#安装流程\" class=\"headerlink\" title=\"安装流程\"></a>安装流程</h4><p>1、创建<code>/etc/yum.repos.d/mongodb-org-4.2.repo</code>文件;<br>2、写入<code>yum</code>安装配置信息<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[mongodb-org-4.2]</span></span><br><span class=\"line\"><span class=\"attr\">name</span>=MongoDB Repository</span><br><span class=\"line\"><span class=\"attr\">baseurl</span>=https://repo.mongodb.org/yum/redhat/<span class=\"variable\">$releasever</span>/mongodb-org/<span class=\"number\">4.1</span>/x<span class=\"number\">86_64</span>/</span><br><span class=\"line\"><span class=\"attr\">gpgcheck</span>=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">enabled</span>=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">gpgkey</span>=https://www.mongodb.org/static/pgp/server-<span class=\"number\">4.2</span>.asc</span><br></pre></td></tr></table></figure></p>\n<p>3、安装MongoDB packages<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum <span class=\"keyword\">install</span> -y mongodb-org-unstable</span><br></pre></td></tr></table></figure></p>\n<p>4、!特定版本packages及组件安装<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">-y</span> <span class=\"selector-tag\">mongodb-org-unstable-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span> <span class=\"selector-tag\">mongodb-org-unstable-server-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span> <span class=\"selector-tag\">mongodb-org-unstable-shell-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span> <span class=\"selector-tag\">mongodb-org-unstable-mongos-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span> <span class=\"selector-tag\">mongodb-org-unstable-tools-4</span><span class=\"selector-class\">.1</span><span class=\"selector-class\">.10</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"启用流程\"><a href=\"#启用流程\" class=\"headerlink\" title=\"启用流程\"></a>启用流程</h4><p>1、MongoDB默认文件创建</p>\n<ul>\n<li>/var/lib/mongo (the data directory)</li>\n<li>/var/log/mongodb (the log directory)</li>\n</ul>\n<p>2、启用MongoDB<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo<span class=\"built_in\"> service </span>mongod start</span><br></pre></td></tr></table></figure></p>\n<p>3、验证启用是否成功<br><code>27017</code>是默认端口，可以在<code>/etc/mongod.conf</code>中更改。<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chkconfig mongod <span class=\"keyword\">on</span></span><br></pre></td></tr></table></figure></p>\n<p>4、关闭MongoDB<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo<span class=\"built_in\"> service </span>mongod stop</span><br></pre></td></tr></table></figure></p>\n<p>5、重启MongoDB<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo<span class=\"built_in\"> service </span>mongod restart</span><br></pre></td></tr></table></figure></p>\n<p>6、MongoDB使用<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">mongo</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"MongoDB权限配置\"><a href=\"#MongoDB权限配置\" class=\"headerlink\" title=\"MongoDB权限配置\"></a>MongoDB权限配置</h4><p>默认安装的MongoDB是不具备权限验证的，因为需要通过Navicat访问远程ECS上的DB服务，为了安全起见，给MongoDB配置相应的权限验证机制是非常必要的。</p>\n<h5 id=\"超级管理员创建\"><a href=\"#超级管理员创建\" class=\"headerlink\" title=\"超级管理员创建\"></a>超级管理员创建</h5><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用mongoDB后使用</span></span><br><span class=\"line\">mongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换至超级管理员模式</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"keyword\">admin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建超级管理员</span></span><br><span class=\"line\">db.createUser(&#123;<span class=\"keyword\">user</span>:<span class=\"string\">'userName'</span>, pwd:<span class=\"string\">'password'</span>, <span class=\"keyword\">roles</span>:[<span class=\"string\">'userAdminAnyDatabase'</span>]&#125;)</span><br></pre></td></tr></table></figure>\n<p>role类型:</p>\n<ul>\n<li>readAnyDatabase 任何数据库的只读权限(和read相似)</li>\n<li>readWriteAnyDatabase 任何数据库的读写权限(和readWrite相似)</li>\n<li>userAdminAnyDatabase 任何数据库用户的管理权限(和userAdmin相似)</li>\n<li>dbAdminAnyDatabase 任何数据库的管理权限(dbAdmin相似)</li>\n</ul>\n<h5 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h5><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入超级管理员模式并验证</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"keyword\">admin</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.auth(<span class=\"string\">'userName'</span>,<span class=\"string\">'password'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看数据库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> dbs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入到elm数据库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> elm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建elm数据库用户</span></span><br><span class=\"line\">db.createUser(&#123;<span class=\"keyword\">user</span>:<span class=\"string\">'user-bayuefen'</span>,pwd:<span class=\"string\">'password'</span>,<span class=\"keyword\">roles</span>:[&#123;<span class=\"keyword\">role</span>:<span class=\"string\">'readWrite'</span>,db:<span class=\"string\">'elm'</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure>\n<p>以上步骤核心完成超级管理员的创建验证及单个数据库的用户创建。<br>具备了以上的权限配置，我们即可通过navicat进行数据库的查看与管理；同时，在<code>Node</code>服务中我们可以使用<code>mongoose</code> package对数据库进行CURD</p>\n<h6 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h6><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mongoose <span class=\"keyword\">from</span> <span class=\"string\">'mongoose'</span>;</span><br><span class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://user:pwd@localhost:27017/elm'</span>, &#123;useMongoClient:<span class=\"literal\">true</span>&#125;);</span><br></pre></td></tr></table></figure>\n<h6 id=\"Navicat\"><a href=\"#Navicat\" class=\"headerlink\" title=\"Navicat\"></a>Navicat</h6><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server: ECS ip</span><br><span class=\"line\">port: 27017 (default)</span><br><span class=\"line\">user: user</span><br><span class=\"line\">pwd: password</span><br><span class=\"line\">db: db_name</span><br></pre></td></tr></table></figure>\n<p>ps:ECS需要通过阿里云后台服务打开安全策略中的27017端口的外网访问权限</p>\n<h4 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h4><p>Q:MongoDB在配置权限之后，重启Mongo,无法启动服务。抛<code>Unit mongod.service entered failed state.</code>异常<br>A:排查后，发现Centos需要将MongoDB添加至<code>systemd</code>中，否则会出现问题。<a href=\"https://github.com/jingxinxin/tiankeng/issues/5\" target=\"_blank\" rel=\"noopener\">Issues</a><br>添加<code>systemd</code><br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /usr/<span class=\"class\"><span class=\"keyword\">lib</span>/<span class=\"title\">systemd</span>/<span class=\"title\">system</span>/<span class=\"title\">mongod</span>.<span class=\"title\">service</span></span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>[Unit]<br>Description=mongodb database</p>\n<p>[Service]<br>User=mongod<br>Group=mongod<br>Environment=”OPTIONS=–quiet -f /etc/mongod.conf”<br>ExecStart=/usr/bin/mongod $OPTIONS run<br>PIDFile=/var/run/mongodb/mongod.pid</p>\n<p>[Install]<br>WantedBy=multi-user.target</p>\n</blockquote>\n<p>创建链接：<br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /usr/<span class=\"class\"><span class=\"keyword\">lib</span>/<span class=\"title\">systemd</span>/<span class=\"title\">system</span>/<span class=\"title\">mongod</span>.<span class=\"title\">service</span> /<span class=\"title\">etc</span>/<span class=\"title\">systemd</span>/<span class=\"title\">system</span>/<span class=\"title\">multi</span>-<span class=\"title\">user</span>.<span class=\"title\">target</span>.<span class=\"title\">wants</span>/</span></span><br></pre></td></tr></table></figure></p>\n<p>重新加载systemctl<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">systemctl daemon-reload</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><ul>\n<li><a href=\"https://docs.mongodb.com/master/tutorial/install-mongodb-on-red-hat/#to-use-non-default-directories\" target=\"_blank\" rel=\"noopener\">Centos7</a></li>\n<li><a href=\"https://docs.mongodb.com/master/tutorial/install-mongodb-on-os-x/\" target=\"_blank\" rel=\"noopener\">macOS</a></li>\n<li><a href=\"https://docs.mongodb.com/master/tutorial/install-mongodb-on-windows/\" target=\"_blank\" rel=\"noopener\">Windows</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjur15bab00002o1aopcuqx9z","tag_id":"cjur15bak00022o1aow8uzdlf","_id":"cjur15baz00092o1amuytsguq"},{"post_id":"cjur15bab00002o1aopcuqx9z","tag_id":"cjur15bay00062o1ayvpeabbr","_id":"cjur15bb0000a2o1akvh8jwt1"},{"post_id":"cjur15bab00002o1aopcuqx9z","tag_id":"cjur15baz00072o1aopz3opvf","_id":"cjur15bb1000c2o1atgv2hz6l"},{"post_id":"cjur15bah00012o1aq9x2se85","tag_id":"cjur15baz00082o1a1irqvps7","_id":"cjur15bb2000f2o1a2hicy138"},{"post_id":"cjur15bah00012o1aq9x2se85","tag_id":"cjur15baz00072o1aopz3opvf","_id":"cjur15bb2000g2o1ar676e92m"},{"post_id":"cjur15bah00012o1aq9x2se85","tag_id":"cjur15bb1000d2o1a1afk0yi0","_id":"cjur15bb3000i2o1a5fa4dayr"},{"post_id":"cjur15bao00032o1aewqqdzv3","tag_id":"cjur15bb2000e2o1adbn5n9c3","_id":"cjur15bb3000j2o1ai6loj0ho"},{"post_id":"cjur15baq00042o1a29j528es","tag_id":"cjur15bak00022o1aow8uzdlf","_id":"cjur15bb4000m2o1a6zehetrq"},{"post_id":"cjur15baq00042o1a29j528es","tag_id":"cjur15bb2000h2o1au2uda028","_id":"cjur15bb4000n2o1agrcmx10a"},{"post_id":"cjur15baq00042o1a29j528es","tag_id":"cjur15baz00072o1aopz3opvf","_id":"cjur15bb4000p2o1a3as42gy7"},{"post_id":"cjur15bax00052o1ao8b80ujd","tag_id":"cjur15bb3000l2o1ahla9xrmh","_id":"cjur15bb5000s2o1azj0v4tny"},{"post_id":"cjur15bax00052o1ao8b80ujd","tag_id":"cjur15bb4000o2o1aj3yierbd","_id":"cjur15bb5000t2o1a9q8sqvug"},{"post_id":"cjur15bax00052o1ao8b80ujd","tag_id":"cjur15bb4000q2o1a0c43e239","_id":"cjur15bb5000u2o1am1e1iooy"},{"post_id":"cjur15bax00052o1ao8b80ujd","tag_id":"cjur15baz00072o1aopz3opvf","_id":"cjur15bb6000v2o1akoj5z9rx"}],"Tag":[{"name":"python","_id":"cjur15bak00022o1aow8uzdlf"},{"name":"unittest","_id":"cjur15bay00062o1ayvpeabbr"},{"name":"日记","_id":"cjur15baz00072o1aopz3opvf"},{"name":"HTTP","_id":"cjur15baz00082o1a1irqvps7"},{"name":"学习Vlog","_id":"cjur15bb1000d2o1a1afk0yi0"},{"name":"css","_id":"cjur15bb2000e2o1adbn5n9c3"},{"name":"requests","_id":"cjur15bb2000h2o1au2uda028"},{"name":"Node","_id":"cjur15bb3000l2o1ahla9xrmh"},{"name":"MongoDB","_id":"cjur15bb4000o2o1aj3yierbd"},{"name":"服务部署","_id":"cjur15bb4000q2o1a0c43e239"}]}}